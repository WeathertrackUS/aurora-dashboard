<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>WTUS SpaceWx</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåå</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg-dark: #0a0a0a;
            --bg-card: #1a1a1a;
            --bg-card-hover: #222222;
            --text-primary: #e5e5e5;
            --text-secondary: #8b8b8b;
            --accent-primary: #666666;
            --accent-secondary: #888888;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: rgba(255, 255, 255, 0.06);
            --glass-border: 1px solid rgba(255, 255, 255, 0.06);
            --glass-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.6);
            --font-sans: 'Inter', system-ui, -apple-system, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-primary);
            font-family: var(--font-sans);
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }

        /* New Dashboard Grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1.4fr 1fr;
            grid-template-rows: 0.6fr 1fr 1fr 1fr 1fr auto;
            gap: 0.5rem;
            width: 100%;
            max-width: 1800px;
            margin: 0 auto;
            padding: 0.5rem;
        }
        
        .chart-panel {
            background: var(--bg-card);
            border: var(--glass-border);
            border-radius: 3px;
            padding: 0.25rem;
            min-height: 100px;
            max-height: 300px;
            position: relative;
            overflow: hidden;
            transition: background 0.2s ease;
        }
        
        .chart-panel:hover {
            background: var(--bg-card-hover);
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .map-panel {
            grid-row: 1 / span 5;
            background: var(--bg-card);
            border: var(--glass-border);
            border-radius: 3px;
            padding: 0.25rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            position: relative;
        }
        
        .map-image {
            width: 100%;
            height: auto;
            max-height: 100%;
            object-fit: contain;
            border-radius: 2px;
        }
        
        .chart-container {
            width: 100%;
            height: 100%;
            min-height: 80px;
            max-height: 260px;
        }

        .chart-title {
            position: absolute;
            top: 8px;
            left: 10px;
            font-size: 0.7rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            z-index: 10;
            pointer-events: none;
            text-transform: uppercase;
            opacity: 0.6;
        }
        
        .chart-value {
            position: absolute;
            top: 6px;
            right: 10px;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
            z-index: 10;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(0,0,0,0.5);
            font-family: 'JetBrains Mono', monospace;
            background: rgba(15, 23, 42, 0.4);
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }

        @media (max-width: 1400px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
            .map-panel {
                grid-row: auto;
                min-height: 500px;
                max-height: 600px;
            }
            .chart-panel {
                min-height: 200px;
            }
            .chart-container {
                min-height: 160px;
            }
        }
        
        @media (max-width: 1024px) {
            .dashboard-grid {
                gap: 0.75rem;
            }
            .map-panel {
                min-height: 400px;
                max-height: 500px;
            }
            .chart-panel {
                min-height: 180px;
            }
            .chart-container {
                min-height: 140px;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(56, 189, 248, 0.15) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(129, 140, 248, 0.15) 0%, transparent 20%),
                radial-gradient(circle at 50% 50%, rgba(168, 85, 247, 0.05) 0%, transparent 50%);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            position: relative;
        }

        /* Noise Texture */
        .bg-noise {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            opacity: 0.03;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        /* Tooltips */
        .tooltip-container {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: help;
            margin-left: 4px;
        }

        .info-icon {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1px solid var(--text-secondary);
            color: var(--text-secondary);
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .tooltip-container:hover .info-icon {
            color: var(--accent-primary);
            border-color: var(--accent-primary);
            background: rgba(56, 189, 248, 0.1);
        }

        .tooltip-content {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0.75rem;
            border-radius: 0.5rem;
            width: 200px;
            font-size: 0.75rem;
            color: var(--text-primary);
            text-transform: none;
            letter-spacing: normal;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 100;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            text-align: center;
            line-height: 1.4;
        }

        .tooltip-container:hover .tooltip-content {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-8px);
        }

        .tooltip-content::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(15, 23, 42, 0.95) transparent transparent transparent;
        }

        /* Navbar */
        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.875rem 2rem;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 0.625rem;
            font-weight: 600;
            font-size: 1.125rem;
            color: var(--text-primary);
            letter-spacing: -0.01em;
            text-decoration: none;
        }

        .brand span {
            font-size: 1.25rem;
        }

        .nav-links {
            display: flex;
            gap: 1.5rem;
            margin-left: 2rem;
            margin-right: auto;
            align-items: center;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            transition: color 0.2s;
        }

        .nav-link:hover {
            color: var(--accent-primary);
        }

        .nav-link.active {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .nav-stats {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .stat-value {
            color: var(--accent-primary);
            font-family: var(--font-mono);
            font-weight: 600;
        }

        /* Main Layout */
        .main-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 1rem;
            padding: 1rem;
            max-width: 1920px;
            margin: 0 auto;
            width: 100%;
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        /* Dashboard Image Area */
        .dashboard-view {
            background: var(--bg-card);
            backdrop-filter: blur(12px);
            border-radius: 4px;
            border: var(--glass-border);
            overflow: hidden;
            position: relative;
            min-height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--glass-shadow);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .dashboard-view:hover {
            box-shadow: 0 20px 40px -5px rgba(0, 0, 0, 0.4);
        }

        .dashboard-image {
            width: 100%;
            height: auto;
            display: block;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .dashboard-image.loaded {
            opacity: 1;
        }

        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .card {
            background: var(--bg-card);
            backdrop-filter: blur(12px);
            border: var(--glass-border);
            border-radius: 4px;
            padding: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }
        
        .card:hover {
            transform: translateY(-2px);
            background: var(--bg-card-hover);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .card-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Live Data Grid */
        .data-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .data-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.75rem;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border: 1px solid transparent;
            transition: border-color 0.2s;
        }
        
        .data-item:hover {
            border-color: rgba(255, 255, 255, 0.1);
        }

        .data-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .data-icon {
            width: 16px;
            height: 16px;
            opacity: 0.7;
        }

        .data-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1;
        }
        
        .data-unit {
            font-size: 0.8rem;
            font-weight: 400;
            color: var(--text-secondary);
            margin-left: 2px;
        }

        .status-badge {
            grid-column: span 2;
            padding: 0.75rem;
            border-radius: 4px;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            background: rgba(56, 189, 248, 0.1);
            color: var(--accent-primary);
            border: 1px solid rgba(56, 189, 248, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.1);
            transition: all 0.3s ease;
        }

        .status-badge.pulse-active {
            animation: badge-pulse 2s infinite;
        }

        @keyframes badge-pulse {
            0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); }
            100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }

        .status-badge.pulse-warning {
            animation: badge-pulse-warning 2s infinite;
        }

        @keyframes badge-pulse-warning {
            0% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(251, 191, 36, 0); }
            100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0); }
        }

        /* Kp Meter */
        .kp-meter-container {
            grid-column: span 2;
            margin-top: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.5rem;
            padding: 0.75rem;
        }
        
        .kp-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
        
        .kp-track {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .kp-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4ade80, #fbbf24, #f87171);
            border-radius: 4px;
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .kp-ticks {
            display: flex;
            justify-content: space-between;
            margin-top: 4px;
            padding: 0 2px;
        }
        
        .kp-tick {
            width: 2px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
        }

        /* Controls */
        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .btn {
            padding: 0.6rem 1rem;
            border-radius: 4px;
            border: none;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }
        
        .btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(255, 255, 255, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .btn:hover::after {
            opacity: 1;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), #0ea5e9);
            color: #0f172a;
            box-shadow: 0 4px 12px rgba(56, 189, 248, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(56, 189, 248, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .btn-full {
            grid-column: span 2;
        }

        /* GIF Generator */
        .form-group {
            margin-bottom: 1.25rem;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .form-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 0.875rem;
            color: var(--text-primary);
            font-family: inherit;
            transition: all 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.1);
        }

        .progress-container {
            margin-top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 999px;
            height: 6px;
            overflow: hidden;
            display: none;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }

        /* Footer */
        footer {
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            padding: 2rem;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: auto;
            background: rgba(15, 23, 42, 0.4);
        }

        /* Utilities */
        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--accent-primary);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 1.5rem;
            border-radius: 4px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 50;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast-success { border-left: 4px solid var(--success); }
        .toast-error { border-left: 4px solid var(--danger); }

        /* Geomagnetic Forecast Styles */
        .forecast-day {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .forecast-date {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .forecast-bar-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .forecast-bar {
            width: 100%;
            height: 120px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        .forecast-fill {
            width: 100%;
            border-radius: 4px;
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1rem;
            color: white;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .forecast-fill.g0 {
            background: linear-gradient(to top, #4ade80, #22c55e);
            height: 16.67%;
        }

        .forecast-fill.g1 {
            background: linear-gradient(to top, #fbbf24, #f59e0b);
            height: 33.33%;
        }

        .forecast-fill.g2 {
            background: linear-gradient(to top, #fb923c, #f97316);
            height: 50%;
        }

        .forecast-fill.g3 {
            background: linear-gradient(to top, #ef4444, #dc2626);
            height: 66.67%;
        }

        .forecast-fill.g4 {
            background: linear-gradient(to top, #dc2626, #b91c1c);
            height: 83.33%;
        }

        .forecast-fill.g5 {
            background: linear-gradient(to top, #991b1b, #7f1d1d);
            height: 100%;
        }

        .forecast-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-top: 0.25rem;
        }

        .forecast-kp {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-family: var(--font-mono);
        }

        .forecast-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .forecast-legend {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.7rem;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        /* Pulse Dot Animation */
        @keyframes pulse-dot {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.85; }
            100% { opacity: 1; }
        }

        /* Mobile Menu Toggle */
        .mobile-menu-toggle {
            display: none;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            z-index: 1001;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .navbar {
                padding: 0.75rem 1rem;
                flex-wrap: wrap;
            }
            
            .mobile-menu-toggle {
                display: block;
            }
            
            .brand {
                font-size: 1rem;
            }
            
            .brand span {
                font-size: 1.1rem;
            }
            
            .nav-links {
                display: none;
                width: 100%;
                margin: 1rem 0 0 0;
                flex-direction: column;
                gap: 0.75rem;
                background: var(--bg-card);
                padding: 1rem;
                border-radius: 0.5rem;
                border: 1px solid var(--border);
            }
            
            .nav-links.active {
                display: flex;
            }
            
            .nav-link {
                font-size: 0.9rem;
                padding: 0.5rem;
            }
            
            .nav-stats {
                gap: 1rem;
            }
            
            .stat-item {
                font-size: 0.75rem;
            }
            
            .main-container {
                padding: 0.5rem;
                gap: 0.5rem;
            }
            
            .dashboard-grid {
                padding: 0.5rem;
                gap: 0.75rem;
            }
            
            .chart-panel {
                border-radius: 4px;
                min-height: 160px;
                max-height: 220px;
                padding: 0.5rem;
            }
            
            .sidebar {
                width: 100%;
                max-width: 100%;
            }
            
            .card {
                margin-bottom: 1rem;
            }
            
            /* Better touch targets */
            button, .btn, select, input {
                min-height: 44px;
                font-size: 1rem;
            }
            
            select {
                padding: 0.75rem;
            }
            
            .map-panel {
                border-radius: 4px;
                min-height: 350px;
                max-height: 450px;
            }
            
            .chart-container {
                min-height: 120px;
                max-height: 180px;
            }
            
            .chart-title {
                font-size: 0.7rem;
                top: 8px;
                left: 10px;
            }
            
            .chart-value {
                font-size: 1rem;
                top: 8px;
                right: 10px;
                padding: 0.1rem 0.3rem;
            }
        }
        
        @media (max-width: 480px) {
            .navbar {
                flex-wrap: wrap;
                padding: 0.5rem 0.75rem;
            }
            
            .brand {
                font-size: 0.9rem;
                flex: 1;
            }
            
            .nav-links {
                order: 3;
                width: 100%;
                margin: 0.5rem 0 0 0;
                justify-content: center;
                gap: 0.75rem;
            }
            
            .nav-stats {
                margin-left: auto;
            }
            
            .main-container {
                padding: 0.5rem;
            }
            
            .dashboard-grid {
                padding: 0.5rem;
                gap: 0.5rem;
            }
            
            .chart-panel {
                min-height: 140px;
                max-height: 200px;
                padding: 0.5rem 0.25rem;
            }
            
            .map-panel {
                min-height: 300px;
                max-height: 400px;
            }
            
            .chart-container {
                min-height: 100px;
                max-height: 160px;
            }
            
            .geomag-forecast-container {
                padding: 0.5rem;
            }
            
            .forecast-day {
                padding: 0.25rem;
            }
            
            .chart-title {
                font-size: 0.65rem;
            }
            
            .chart-value {
                font-size: 0.95rem;
            }
            
            /* Hide beta badge on very small screens */
            .brand span[style*="BETA"] {
                display: none;
            }
            
            /* Stack sidebar items more compactly */
            .sidebar .card {
                margin-bottom: 0.75rem;
            }
            
            /* Optimize forecast day cards */
            .forecast-day {
                min-height: 60px;
            }
            
            /* Improve moon phase card */
            #moon-image {
                width: 80px !important;
                height: 80px !important;
            }
        }
        
        /* Touch-specific improvements */
        @media (hover: none) and (pointer: coarse) {
            /* Larger touch targets */
            button, .btn, a {
                min-height: 44px;
                min-width: 44px;
            }
            
            /* Prevent text selection on buttons */
            button, .btn {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
            }
            
            /* Smoother scrolling */
            * {
                -webkit-overflow-scrolling: touch;
            }
        }
    </style>
</head>
<body>
    <div class="bg-noise"></div>
    <nav class="navbar">
        <a href="/" class="brand">
            <span></span> WTUS Space Weather Dashboard
            <span style="margin-left: 0.5rem; font-size: 0.6rem; background: rgba(139, 139, 139, 0.2); color: #8b8b8b; padding: 0.2rem 0.4rem; border-radius: 3px; border: 1px solid rgba(139, 139, 139, 0.3); font-weight: 600; letter-spacing: 0.05em;">BETA</span>
        </a>
        <button class="mobile-menu-toggle" onclick="toggleMobileMenu()" aria-label="Toggle menu">
            ‚ò∞
        </button>
        <div class="nav-links" id="nav-links">
            <a href="/" class="nav-link active">Geomagnetic Activity</a>
            <a href="/solar" class="nav-link">Solar Activity</a>
        </div>
        <div class="nav-stats">
            <div class="stat-item">
                <span>Time:</span>
                <span class="stat-value" id="utc-time">--:--</span>
            </div>
        </div>
    </nav>

    <main class="main-container">
        <!-- Alert Banner (hidden by default) -->
        <div id="alert-banner" style="display: none; background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.15)); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 3px; padding: 0.75rem 1rem; margin: 0.5rem; animation: pulse 2s ease-in-out infinite;">
            <div style="display: flex; align-items: center; gap: 0.75rem;">
                <span style="font-size: 1.5rem;">‚ö†Ô∏è</span>
                <div style="flex: 1;">
                    <div style="font-weight: 600; color: #fca5a5; margin-bottom: 0.25rem;">Geomagnetic Storm Alert</div>
                    <div id="alert-message" style="color: #e5e5e5; font-size: 0.9rem;"></div>
                </div>
                <button onclick="document.getElementById('alert-banner').style.display='none'" style="background: none; border: none; color: #8b8b8b; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem;">&times;</button>
            </div>
        </div>

        <!-- Left Column: Main Visualization -->
        <div class="dashboard-grid">
            <!-- Map Panel -->
            <div class="map-panel">
                <div class="chart-title" style="font-size: 1.1rem; color: var(--accent-primary); top: 20px; left: 20px;">AURORAL OVAL</div>
                <div class="loading-overlay" id="loading-overlay">
                    <div class="spinner"></div>
                    <p>Updating Data...</p>
                </div>
                <img src="/aurora-map.png" alt="Aurora Map" class="map-image" id="map-image">
            </div>
            
            <!-- Charts Column -->
            <div class="chart-panel">
                <div class="chart-title">PLANETARY K-INDEX</div>
                <div class="chart-value" id="kp-value-text">--</div>
                <div style="height: 100%; display: flex; flex-direction: column; justify-content: center; padding-top: 1.25rem;">
                     <div id="g-scale-display" style="text-align: center; margin-bottom: 0.5rem; font-family: 'JetBrains Mono', monospace; font-weight: 700; font-size: 1.2rem; color: var(--text-secondary); opacity: 0.5; line-height: 1;">
                        G0 <span style="font-size: 0.7rem; font-weight: 400; opacity: 0.7;">STORM SCALE</span>
                     </div>
                     <div class="kp-track" style="height: 10px; background: rgba(255,255,255,0.1); border-radius: 2px;">
                         <div class="kp-fill" id="kp-fill" style="border-radius: 2px;"></div>
                     </div>
                     <div class="kp-ticks" style="margin-top: 4px;">
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                     </div>
                </div>
            </div>

            <div class="chart-panel">
                <div class="chart-title">SOLAR WIND SPEED</div>
                <div class="chart-value" id="chart-val-speed">--</div>
                <div id="chart-speed" class="chart-container"></div>
            </div>
            
            <div class="chart-panel">
                <div class="chart-title">PROTON DENSITY</div>
                <div class="chart-value" id="chart-val-density">--</div>
                <div id="chart-density" class="chart-container"></div>
            </div>
            
            <div class="chart-panel">
                <div class="chart-title">IMF Bt</div>
                <div class="chart-value" id="chart-val-bt">--</div>
                <div id="chart-bt" class="chart-container"></div>
            </div>
            
            <div class="chart-panel">
                <div class="chart-title">IMF Bz</div>
                <div class="chart-value" id="chart-val-bz">--</div>
                <div id="chart-bz" class="chart-container"></div>
            </div>
            
            <!-- Bottom Row: Magnetometer & Power -->
            <div class="chart-panel" style="grid-column: 1 / -1; display: grid; grid-template-columns: 2fr 1fr; gap: 0.5rem; min-height: 240px;">
                <div style="position: relative;">
                    <div class="chart-title">GOES MAGNETOMETER</div>
                    <div id="chart-mag" class="chart-container"></div>
                </div>
                <div style="position: relative;">
                    <div class="chart-title">HEMISPHERIC POWER</div>
                    <div class="chart-value" id="chart-val-power">--</div>
                    <div id="chart-power" class="chart-container"></div>
                </div>
            </div>
        </div>

        <!-- Right Column: Sidebar -->
        <aside class="sidebar">
            <!-- Geomagnetic Forecast Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">3-Day Geomagnetic Forecast</div>
                </div>
                <div id="geomag-forecast-container" style="padding: 0.75rem;">
                    <p style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 1rem;">Loading forecast...</p>
                </div>
            </div>

            <!-- Controls Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Aurora Visibility</div>
                </div>
                <div style="padding: 0.75rem;">
                    <div style="margin-bottom: 0.75rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">Your Latitude</label>
                        <input type="number" id="user-latitude" placeholder="e.g., 45.5" step="0.1" min="-90" max="90" 
                               style="width: 100%; padding: 0.5rem; background: var(--bg-card); border: 1px solid var(--border); border-radius: 3px; color: var(--text-primary); font-family: var(--font-mono);"
                               onchange="updateAuroraProbability()">
                    </div>
                    <div id="aurora-prob-display" style="text-align: center; padding: 1rem; background: rgba(255,255,255,0.03); border-radius: 3px; border: 1px solid var(--border);">
                        <div style="font-size: 2rem; font-weight: 700; font-family: var(--font-mono); margin-bottom: 0.5rem;" id="prob-percentage">--%</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);" id="prob-visibility">Enter your latitude</div>
                    </div>
                </div>
            </div>

            <!-- Timezone Selector Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Display Settings</div>
                </div>
                <div style="padding: 0.75rem;">
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">Timezone</label>
                    <select id="timezone-selector" onchange="updateTimezone()" 
                            style="width: 100%; padding: 0.5rem; background: var(--bg-card); border: 1px solid var(--border); border-radius: 3px; color: var(--text-primary); font-family: var(--font-sans);">
                        <option value="UTC">UTC (Universal Time)</option>
                        <option value="local">Local Time</option>
                        <option value="America/New_York">Eastern Time</option>
                        <option value="America/Chicago">Central Time</option>
                        <option value="America/Denver">Mountain Time</option>
                        <option value="America/Los_Angeles">Pacific Time</option>
                        <option value="America/Anchorage">Alaska Time</option>
                        <option value="Pacific/Honolulu">Hawaii Time</option>
                    </select>
                </div>
            </div>

            <!-- Moon Phase Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Current Moon Phase</div>
                </div>
                <div style="padding: 1.5rem; text-align: center;">
                    <img id="moon-image" src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23333' stroke='%23999' stroke-width='2'/></svg>" alt="Moon Phase" style="width: 120px; height: 120px; margin-bottom: 0.5rem;">
                    <div style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text-primary);" id="moon-phase-name">New Moon</div>
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem;" id="moon-illumination">0% illuminated</div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary); padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 3px;" id="moon-visibility-impact"></div>
                </div>
            </div>

            <!-- Controls Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Controls</div>
                </div>
                <div class="control-grid">
                    <button class="btn btn-primary btn-full" onclick="refreshDashboard()">
                         Refresh Now
                    </button>
                    <button class="btn btn-secondary" id="download-btn" onclick="downloadDashboard()">
                         Download
                    </button>
                    <button class="btn btn-secondary" onclick="copyImageToClipboard()">
                         Copy
                    </button>
                </div>
            </div>

        </aside>
    </main>
    <footer>
        <p>Data provided by NOAA Space Weather Prediction Center</p>
        <p style="margin-top: 0.5rem; opacity: 0.6;">&copy; 2025 Weather Track US</p>
    </footer>

    <div class="toast" id="toast">
        <span id="toast-icon">‚úÖ</span>
        <span id="toast-message">Operation successful</span>
    </div>

    <script>
        // State
        let nextRefreshTime = Date.now() + 60000;
        let refreshTimer;
        let countdownTimer;

        // Elements
        const mapImage = document.getElementById('map-image');
        const loadingOverlay = document.getElementById('loading-overlay');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            refreshDashboard();
            startTimers();
            
            // Load saved settings
            const savedLat = localStorage.getItem('userLatitude');
            if (savedLat) {
                document.getElementById('user-latitude').value = savedLat;
                updateAuroraProbability();
            }
            
            const savedTz = localStorage.getItem('timezone');
            if (savedTz) {
                document.getElementById('timezone-selector').value = savedTz;
                currentTimezone = savedTz;
            }
            
            // Initialize moon phase
            calculateMoonPhase();
            
            // Update time displays
            updateUtcTime();
            setInterval(updateUtcTime, 1000);
            
            // Update moon phase daily
            setInterval(calculateMoonPhase, 3600000); // Update every hour
        });

        function updateUtcTime() {
            const now = new Date();
            document.getElementById('utc-time').textContent = now.toISOString().slice(11, 16) + ' UTC';
        }

        function startTimers() {
            // Countdown timer
            countdownTimer = setInterval(() => {
                const now = Date.now();
                const diff = Math.ceil((nextRefreshTime - now) / 1000);
                
                if (diff <= 0) {
                    document.getElementById('countdown').textContent = 'Refreshing...';
                } else {
                    document.getElementById('countdown').textContent = `${diff}s`;
                }
            }, 1000);

            // Auto refresh timer
            refreshTimer = setInterval(refreshDashboard, 60000);
        }

        async function refreshDashboard() {
            loadingOverlay.classList.add('active');

            try {
                // 1. Fetch Data
                const dataResponse = await fetch('/api/aurora-data');
                const data = await dataResponse.json();
                
                // 2. Update UI
                updateDataCard(data);
                renderCharts(data);
                
                // 3. Check for alerts
                checkForAlerts(data);
                
                // 4. Update aurora probability if latitude is set
                if (document.getElementById('user-latitude').value) {
                    updateAuroraProbability();
                }

                // 5. Fetch Geomagnetic Alerts
                fetchGeomagneticAlerts();

                // 4. Refresh Map Image
                const timestamp = new Date().getTime();
                const newSrc = `/aurora-map.png?t=${timestamp}`;
                
                // Preload image
                const tempImg = new Image();
                tempImg.onload = () => {
                    mapImage.src = newSrc;
                    loadingOverlay.classList.remove('active');
                    nextRefreshTime = Date.now() + 60000;
                };
                tempImg.src = newSrc;
                
                // Force resize to fix layout bugs
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 100);

            } catch (error) {
                console.error('Error refreshing dashboard:', error);
                showToast('Failed to refresh data', 'error');
                loadingOverlay.classList.remove('active');
            }
        }

        async function fetchGeomagneticAlerts() {
            try {
                const response = await fetch('/api/geomagnetic-alerts');
                const data = await response.json();
                
                const container = document.getElementById('geomag-forecast-container');
                if (!container) return;
                
                if (!data.forecast || data.forecast.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 1rem;">No forecast data available</p>';
                    return;
                }
                
                // Build the forecast chart
                let html = '<div class="forecast-grid">';
                
                data.forecast.forEach((day, index) => {
                    // Parse the date string in UTC to avoid timezone boundary issues
                    const date = new Date(day.date + 'T00:00:00Z');
                    
                    const dayName = index === 0 ? 'Today' : 
                                   index === 1 ? 'Tomorrow' : 
                                   date.toLocaleDateString('en-US', { weekday: 'short', timeZone: 'UTC' });
                    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'UTC' });
                    
                    const gScale = day.g_scale;
                    const gClass = `g${gScale}`;
                    const gLabel = gScale === 0 ? 'Quiet' : `G${gScale}`;
                    
                    html += `
                        <div class="forecast-day">
                            <div class="forecast-date">${dayName}</div>
                            <div class="forecast-date" style="font-size: 0.65rem; margin-top: -0.25rem;">${dateStr}</div>
                            <div class="forecast-bar-container">
                                <div class="forecast-bar">
                                    <div class="forecast-fill ${gClass}">
                                        ${gLabel}
                                    </div>
                                </div>
                                <div class="forecast-kp">Kp ${day.max_kp}</div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                // Add legend with separate colors for each G-level
                html += `
                    <div class="forecast-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ade80;"></div>
                            <span>G0</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #fbbf24;"></div>
                            <span>G1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #fb923c;"></div>
                            <span>G2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ef4444;"></div>
                            <span>G3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #dc2626;"></div>
                            <span>G4</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #991b1b;"></div>
                            <span>G5</span>
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Error fetching geomagnetic forecast:', error);
            }
        }

        function renderCharts(data) {
            const commonLayout = {
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#94a3b8', family: 'Inter, sans-serif' },
                margin: { t: 25, r: 8, b: 25, l: 35 },
                xaxis: { showgrid: false, zeroline: false, tickfont: { size: 10 }, fixedrange: true },
                yaxis: { showgrid: true, gridcolor: 'rgba(255,255,255,0.05)', zeroline: false, tickfont: { size: 10 }, fixedrange: true },
                showlegend: false,
                autosize: true,
                responsive: true
            };

            const config = { displayModeBar: false, responsive: true, autosizable: true };

            // Helper for traces
            const createTrace = (x, y, color, fill = 'tozeroy') => ({
                x: x, y: y,
                type: 'scatter',
                mode: 'lines',
                fill: fill,
                line: { color: color, width: 2 },
                fillcolor: color + '33' // 20% opacity
            });

            // 1. Solar Wind Speed with Gradient Fill
            if (data.solar_wind_history) {
                const hist = data.solar_wind_history;
                
                // Dynamic Y-axis range
                const speeds = hist.speeds.filter(s => s !== null);
                const maxSpeed = Math.max(...speeds, 400);
                const minSpeed = Math.min(...speeds, 200);
                const yMin = Math.max(0, minSpeed - 50);
                const yMax = maxSpeed + 100;
                
                // Create smooth gradient using SVG pattern approach
                // Generate many thin gradient layers but with proper blending
                const traces = [];
                const steps = 300; // Increased for ultra-smooth gradient
                
                for (let i = 0; i < steps; i++) {
                    const yBottom = yMin + (i / steps) * (yMax - yMin);
                    const yTop = yMin + ((i + 1) / steps) * (yMax - yMin);
                    const yMid = (yBottom + yTop) / 2;
                    
                    // Smooth color interpolation across the full range
                    let r, g, b;
                    const normalizedY = (yMid - yMin) / (yMax - yMin);
                    
                    if (normalizedY < 0.25) {
                        // Green to light green
                        const t = normalizedY / 0.25;
                        r = 74 + (217 - 74) * t;
                        g = 222 + (249 - 222) * t;
                        b = 128 + (157 - 128) * t;
                    } else if (normalizedY < 0.45) {
                        // Light green to yellow
                        const t = (normalizedY - 0.25) / 0.20;
                        r = 217 + (250 - 217) * t;
                        g = 249 + (204 - 249) * t;
                        b = 157 + (21 - 157) * t;
                    } else if (normalizedY < 0.65) {
                        // Yellow to orange
                        const t = (normalizedY - 0.45) / 0.20;
                        r = 250 + (251 - 250) * t;
                        g = 204 + (146 - 204) * t;
                        b = 21 + (60 - 21) * t;
                    } else if (normalizedY < 0.80) {
                        // Orange to red
                        const t = (normalizedY - 0.65) / 0.15;
                        r = 251 + (239 - 251) * t;
                        g = 146 + (68 - 146) * t;
                        b = 60 + (68 - 60) * t;
                    } else if (normalizedY < 0.95) {
                        // Red to pink
                        const t = (normalizedY - 0.80) / 0.15;
                        r = 239 + (236 - 239) * t;
                        g = 68 + (72 - 68) * t;
                        b = 68 + (153 - 68) * t;
                    } else {
                        // Pink to white
                        const t = (normalizedY - 0.95) / 0.05;
                        r = 236 + (255 - 236) * t;
                        g = 72 + (255 - 72) * t;
                        b = 153 + (255 - 153) * t;
                    }
                    
                    // Very transparent layers for smooth blending
                    const opacity = 0.5; // Increased opacity for visibility
                    const color = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${opacity})`;
                    
                    // Create smooth interpolated points for this band
                    const xPoints = hist.times;
                    const yPoints = hist.speeds.map(s => {
                        if (s === null) return yMin;
                        // Clamp speed value to this band
                        return Math.min(Math.max(s, yBottom), yTop);
                    });
                    
                    // Build closed polygon
                    const xFill = [...xPoints, ...xPoints.slice().reverse()];
                    const yFill = [...yPoints, ...new Array(xPoints.length).fill(yBottom).reverse()];
                    
                    traces.push({
                        x: xFill,
                        y: yFill,
                        type: 'scatter',
                        mode: 'none',
                        fill: 'toself',
                        fillcolor: color,
                        line: { width: 0 },
                        hoverinfo: 'skip',
                        showlegend: false
                    });
                }
                
                // White line on top
                traces.push({
                    x: hist.times, 
                    y: hist.speeds,
                    type: 'scatter',
                    mode: 'lines',
                    line: { 
                        color: '#f8fafc',
                        width: 2.5,
                        shape: 'spline',
                        smoothing: 1.3
                    },
                    hovertemplate: '%{y:.0f} km/s<extra></extra>',
                    name: 'Speed'
                });

                const layout = { 
                    ...commonLayout, 
                    yaxis: { ...commonLayout.yaxis, title: '', range: [yMin, yMax] }
                };
                
                Plotly.newPlot('chart-speed', traces, layout, config);
                
                const lastVal = hist.speeds[hist.speeds.length - 1];
                const valElem = document.getElementById('chart-val-speed');
                if (lastVal) {
                    valElem.textContent = Math.round(lastVal) + ' km/s';
                    if (lastVal >= 1000) valElem.style.color = '#ffffff';
                    else if (lastVal >= 850) valElem.style.color = '#ec4899';
                    else if (lastVal >= 750) valElem.style.color = '#ef4444';
                    else if (lastVal >= 600) valElem.style.color = '#fb923c';
                    else if (lastVal >= 450) valElem.style.color = '#facc15';
                    else if (lastVal >= 350) valElem.style.color = '#d9f99d';
                    else valElem.style.color = '#4ade80';
                }
            }

            // 2. Density with Gradient
            if (data.solar_wind_history) {
                const hist = data.solar_wind_history;
                const densities = hist.densities.filter(d => d !== null);
                const maxDensity = Math.max(...densities);
                const minDensity = Math.min(...densities, 0);
                const range = maxDensity - minDensity;
                const yMin = Math.max(0, minDensity - range * 0.3);
                const yMax = maxDensity + range * 2;
                
                const traces = [];
                const steps = 300;
                
                for (let i = 0; i < steps; i++) {
                    const yBottom = yMin + (i / steps) * (yMax - yMin);
                    const yTop = yMin + ((i + 1) / steps) * (yMax - yMin);
                    const yMid = (yBottom + yTop) / 2;
                    
                    // Density color scale based on value
                    let r, g, b;
                    if (yMid < 5) {
                        // 0-5: light green
                        const t = yMid / 5;
                        r = 187 + (134 - 187) * t;
                        g = 247 + (239 - 247) * t;
                        b = 208 + (160 - 208) * t;
                    } else if (yMid < 10) {
                        // 5-10: dark green
                        const t = (yMid - 5) / 5;
                        r = 134 + (22 - 134) * t;
                        g = 239 + (163 - 239) * t;
                        b = 160 + (74 - 160) * t;
                    } else if (yMid < 20) {
                        // 10-20: yellow
                        const t = (yMid - 10) / 10;
                        r = 22 + (250 - 22) * t;
                        g = 163 + (204 - 163) * t;
                        b = 74 + (21 - 74) * t;
                    } else if (yMid < 30) {
                        // 20-30: orange to red
                        const t = (yMid - 20) / 10;
                        r = 250 + (239 - 250) * t;
                        g = 204 + (68 - 204) * t;
                        b = 21 + (68 - 21) * t;
                    } else if (yMid < 40) {
                        // 30-40: dark red
                        const t = (yMid - 30) / 10;
                        r = 239 + (153 - 239) * t;
                        g = 68 + (27 - 68) * t;
                        b = 68 + (27 - 68) * t;
                    } else if (yMid < 50) {
                        // 40-50: purple
                        const t = (yMid - 40) / 10;
                        r = 153 + (147 - 153) * t;
                        g = 27 + (51 - 27) * t;
                        b = 27 + (234 - 27) * t;
                    } else {
                        // 50+: pink
                        const t = Math.min((yMid - 50) / 20, 1);
                        r = 147 + (236 - 147) * t;
                        g = 51 + (72 - 51) * t;
                        b = 234 + (153 - 234) * t;
                    }
                    
                    const color = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, 0.5)`;
                    const xPoints = hist.times;
                    const yPoints = hist.densities.map(d => d === null ? yMin : Math.min(Math.max(d, yBottom), yTop));
                    const xFill = [...xPoints, ...xPoints.slice().reverse()];
                    const yFill = [...yPoints, ...new Array(xPoints.length).fill(yBottom).reverse()];
                    
                    traces.push({
                        x: xFill, y: yFill,
                        type: 'scatter', mode: 'none',
                        fill: 'toself', fillcolor: color,
                        line: { width: 0 },
                        hoverinfo: 'skip', showlegend: false
                    });
                }
                
                traces.push({
                    x: hist.times, y: hist.densities,
                    type: 'scatter', mode: 'lines',
                    line: { color: '#f8fafc', width: 2.5, shape: 'spline', smoothing: 1.3 },
                    hovertemplate: '%{y:.1f}<extra></extra>'
                });
                
                const layout = { ...commonLayout, yaxis: { ...commonLayout.yaxis, range: [yMin, yMax] } };
                Plotly.newPlot('chart-density', traces, layout, config);
                
                const lastVal = hist.densities[hist.densities.length - 1];
                document.getElementById('chart-val-density').textContent = lastVal ? lastVal.toFixed(1) : '--';
            }

            // 3. Bt with Gradient
            if (data.solar_wind_history) {
                const hist = data.solar_wind_history;
                const bts = hist.bts.filter(b => b !== null);
                const maxBt = Math.max(...bts, 10);
                const minBt = Math.min(...bts, 0);
                const yMin = Math.max(0, minBt - 2);
                const yMax = maxBt + 3;
                
                const traces = [];
                const steps = 300;
                
                for (let i = 0; i < steps; i++) {
                    const yBottom = yMin + (i / steps) * (yMax - yMin);
                    const yTop = yMin + ((i + 1) / steps) * (yMax - yMin);
                    const yMid = (yBottom + yTop) / 2;
                    
                    // Bt color scale based on value (same as Density)
                    let r, g, b;
                    if (yMid < 5) {
                        // 0-5: light green
                        const t = yMid / 5;
                        r = 187 + (134 - 187) * t;
                        g = 247 + (239 - 247) * t;
                        b = 208 + (160 - 208) * t;
                    } else if (yMid < 10) {
                        // 5-10: dark green
                        const t = (yMid - 5) / 5;
                        r = 134 + (22 - 134) * t;
                        g = 239 + (163 - 239) * t;
                        b = 160 + (74 - 160) * t;
                    } else if (yMid < 20) {
                        // 10-20: yellow
                        const t = (yMid - 10) / 10;
                        r = 22 + (250 - 22) * t;
                        g = 163 + (204 - 163) * t;
                        b = 74 + (21 - 74) * t;
                    } else if (yMid < 30) {
                        // 20-30: orange to red
                        const t = (yMid - 20) / 10;
                        r = 250 + (239 - 250) * t;
                        g = 204 + (68 - 204) * t;
                        b = 21 + (68 - 21) * t;
                    } else if (yMid < 40) {
                        // 30-40: dark red
                        const t = (yMid - 30) / 10;
                        r = 239 + (153 - 239) * t;
                        g = 68 + (27 - 68) * t;
                        b = 68 + (27 - 68) * t;
                    } else if (yMid < 50) {
                        // 40-50: purple
                        const t = (yMid - 40) / 10;
                        r = 153 + (147 - 153) * t;
                        g = 27 + (51 - 27) * t;
                        b = 27 + (234 - 27) * t;
                    } else {
                        // 50+: pink
                        const t = Math.min((yMid - 50) / 20, 1);
                        r = 147 + (236 - 147) * t;
                        g = 51 + (72 - 51) * t;
                        b = 234 + (153 - 234) * t;
                    }
                    
                    const color = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, 0.5)`;
                    const xPoints = hist.times;
                    const yPoints = hist.bts.map(b => b === null ? yMin : Math.min(Math.max(b, yBottom), yTop));
                    const xFill = [...xPoints, ...xPoints.slice().reverse()];
                    const yFill = [...yPoints, ...new Array(xPoints.length).fill(yBottom).reverse()];
                    
                    traces.push({
                        x: xFill, y: yFill,
                        type: 'scatter', mode: 'none',
                        fill: 'toself', fillcolor: color,
                        line: { width: 0 },
                        hoverinfo: 'skip', showlegend: false
                    });
                }
                
                traces.push({
                    x: hist.times, y: hist.bts,
                    type: 'scatter', mode: 'lines',
                    line: { color: '#f8fafc', width: 2.5, shape: 'spline', smoothing: 1.3 },
                    hovertemplate: '%{y:.1f} nT<extra></extra>'
                });
                
                const layout = { ...commonLayout, yaxis: { ...commonLayout.yaxis, range: [yMin, yMax] } };
                Plotly.newPlot('chart-bt', traces, layout, config);
                
                const lastVal = hist.bts[hist.bts.length - 1];
                document.getElementById('chart-val-bt').textContent = lastVal ? lastVal.toFixed(1) + ' nT' : '--';
            }

            // 4. Bz - Simple solid fills (gradient causes artifacts with bipolar data)
            if (data.solar_wind_history) {
                const hist = data.solar_wind_history;
                const bzs = hist.bzs.filter(b => b !== null);
                const maxBz = Math.max(...bzs, 5);
                const minBz = Math.min(...bzs, -5);
                const yMin = minBz - 2;
                const yMax = maxBz + 2;
                
                const traces = [];
                
                // Positive fill - green
                traces.push({
                    x: hist.times,
                    y: hist.bzs.map(v => v > 0 ? v : 0),
                    type: 'scatter',
                    mode: 'none',
                    fill: 'tozeroy',
                    fillcolor: 'rgba(74, 222, 128, 0.4)',
                    hoverinfo: 'skip',
                    showlegend: false,
                    line: { width: 0 }
                });
                
                // Negative fill - red
                traces.push({
                    x: hist.times,
                    y: hist.bzs.map(v => v < 0 ? v : 0),
                    type: 'scatter',
                    mode: 'none',
                    fill: 'tozeroy',
                    fillcolor: 'rgba(248, 113, 113, 0.4)',
                    hoverinfo: 'skip',
                    showlegend: false,
                    line: { width: 0 }
                });
                
                traces.push({
                    x: hist.times, y: hist.bzs,
                    type: 'scatter', mode: 'lines',
                    line: { color: '#f8fafc', width: 2.5, shape: 'spline', smoothing: 1.3 },
                    hovertemplate: '%{y:.1f} nT<extra></extra>'
                });
                
                const layout = { 
                    ...commonLayout,
                    yaxis: { ...commonLayout.yaxis, range: [yMin, yMax] },
                    shapes: [{ type: 'line', x0: 0, x1: 1, xref: 'paper', y0: 0, y1: 0, line: { color: 'rgba(255,255,255,0.3)', width: 1 } }],
                    autosize: true,
                    margin: { l: 35, r: 10, t: 10, b: 25 }
                };
                Plotly.newPlot('chart-bz', traces, layout, config);
                
                const lastVal = hist.bzs[hist.bzs.length - 1];
                const valElem = document.getElementById('chart-val-bz');
                if (lastVal !== null) {
                    valElem.textContent = lastVal.toFixed(1) + ' nT';
                    valElem.style.color = lastVal < 0 ? '#ff4444' : '#4ade80';
                }
            }

            // 5. Magnetometer
            if (data.goes_magnetometer) {
                const mag = data.goes_magnetometer;
                const trace18 = {
                    x: mag.goes18_times, y: mag.goes18_hp,
                    name: 'GOES-18', type: 'scatter', mode: 'lines',
                    line: { color: '#4477ff', width: 2 }
                };
                const trace19 = {
                    x: mag.goes19_times, y: mag.goes19_hp,
                    name: 'GOES-19', type: 'scatter', mode: 'lines',
                    line: { color: '#ff4444', width: 2 }
                };
                
                const layout = { 
                    ...commonLayout, 
                    showlegend: true,
                    legend: { x: 0, y: 1, font: { color: '#fff' }, bgcolor: 'rgba(0,0,0,0)' }
                };
                Plotly.newPlot('chart-mag', [trace18, trace19], layout, config);
            }

            // 6. Hemispheric Power
            if (data.hemispheric_power) {
                const power = data.hemispheric_power;
                const count = 20;
                const times = power.times.slice(-count);
                const values = power.powers.slice(-count);
                
                const colors = values.map(v => {
                    if (v < 30) return '#888888';
                    if (v < 50) return '#00ff00';
                    if (v < 100) return '#ffaa00';
                    return '#ff0000';
                });

                const trace = {
                    x: times, y: values,
                    type: 'bar',
                    marker: { color: colors }
                };
                
                Plotly.newPlot('chart-power', [trace], commonLayout, config);
                
                const lastVal = values[values.length - 1];
                document.getElementById('chart-val-power').textContent = lastVal ? Math.round(lastVal) + ' GW' : '--';
            }
            
            // Force Plotly to resize all charts after render
            setTimeout(() => {
                const chartIds = ['chart-speed', 'chart-density', 'chart-bt', 'chart-bz', 'chart-mag', 'chart-power'];
                chartIds.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        Plotly.Plots.resize(element);
                    }
                });
            }, 100);
        }

        function updateDataCard(data) {
            const safeVal = (val, decimals = 1) => val !== null && val !== undefined ? Number(val).toFixed(decimals) : '--';
            
            const kp = data.kp_index?.kp || 0;
            document.getElementById('kp-value-text').textContent = safeVal(kp);
            const kpFill = document.getElementById('kp-fill');
            const kpPercent = Math.min((kp / 9) * 100, 100);
            kpFill.style.width = `${kpPercent}%`;
            
            // G-Scale Calculation
            let gScale = 0;
            if (kp >= 9) gScale = 5;
            else if (kp >= 8) gScale = 4;
            else if (kp >= 7) gScale = 3;
            else if (kp >= 6) gScale = 2;
            else if (kp >= 5) gScale = 1;
            
            const gElem = document.getElementById('g-scale-display');
            gElem.innerHTML = `G${gScale} <span style="font-size: 0.8rem; font-weight: 400; opacity: 0.7;">STORM SCALE</span>`;
            
            if (gScale >= 4) {
                gElem.style.color = 'var(--danger)';
                gElem.style.opacity = '1';
                gElem.style.textShadow = '0 0 20px rgba(248, 113, 113, 0.5)';
            } else if (gScale >= 1) {
                gElem.style.color = 'var(--warning)';
                gElem.style.opacity = '1';
                gElem.style.textShadow = '0 0 15px rgba(251, 191, 36, 0.3)';
            } else {
                gElem.style.color = 'var(--text-secondary)';
                gElem.style.opacity = '0.5';
                gElem.style.textShadow = 'none';
            }
            
            if (kp >= 5) kpFill.style.background = 'var(--danger)';
            else if (kp >= 4) kpFill.style.background = 'var(--warning)';
            else kpFill.style.background = 'var(--success)';




        }

        async function downloadDashboard() {
            try {
                const canvas = await createDashboardCanvas();
                const link = document.createElement('a');
                link.download = `aurora_dashboard_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                showToast('Dashboard downloaded', 'success');
            } catch (err) {
                console.error(err);
                showToast('Failed to download dashboard', 'error');
            }
        }

        async function copyImageToClipboard() {
            try {
                const canvas = await createDashboardCanvas();
                canvas.toBlob(async (blob) => {
                    await navigator.clipboard.write([
                        new ClipboardItem({ 'image/png': blob })
                    ]);
                    showToast('Dashboard copied to clipboard', 'success');
                });
            } catch (err) {
                console.error(err);
                showToast('Failed to copy image', 'error');
            }
        }

        async function createDashboardCanvas() {
            // Create a canvas to compose all elements
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size matching reference layout (landscape, ~16:10 aspect)
            const width = 2400;
            const height = 1500;
            canvas.width = width;
            canvas.height = height;
            
            // Fill background
            ctx.fillStyle = '#0b1121';
            ctx.fillRect(0, 0, width, height);
            
            // Layout dimensions
            const mapWidth = 1100;
            const mapHeight = 1200;
            const chartWidth = 1300;
            const chartHeight = 300;
            const bottomHeight = 280;
            
            // Get aurora map (left side, top portion)
            const mapImg = await loadImage(mapImage.src);
            ctx.drawImage(mapImg, 0, 0, mapWidth, mapHeight);
            
            // Draw Kp Index panel at top right (recreate the visual)
            const kpPanelX = mapWidth;
            const kpPanelY = 0;
            const kpPanelHeight = 120;
            
            // Kp panel background
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(kpPanelX + 20, kpPanelY + 20, chartWidth - 40, kpPanelHeight);
            
            // Kp title
            ctx.fillStyle = '#94a3b8';
            ctx.font = 'bold 20px Metropolis, sans-serif';
            ctx.fillText('PLANETARY K-INDEX', kpPanelX + 40, kpPanelY + 50);
            
            // Kp value
            const kpValue = document.getElementById('kp-value-text').textContent;
            ctx.fillStyle = '#f8fafc';
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(kpValue, kpPanelX + chartWidth - 40, kpPanelY + 55);
            ctx.textAlign = 'left';
            
            // G-Scale display
            const gScaleText = document.getElementById('g-scale-display').textContent;
            ctx.fillStyle = '#94a3b8';
            ctx.font = 'bold 18px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(gScaleText, kpPanelX + chartWidth / 2, kpPanelY + 85);
            ctx.textAlign = 'left';
            
            // Kp meter bar
            const kpFill = document.getElementById('kp-fill');
            const kpPercent = parseFloat(kpFill.style.width) || 0;
            const barX = kpPanelX + 40;
            const barY = kpPanelY + 95;
            const barWidth = chartWidth - 80;
            const barHeight = 10;
            
            // Background bar
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            // Filled bar
            const fillWidth = (barWidth * kpPercent) / 100;
            const fillColor = kpFill.style.background || '#4ade80';
            ctx.fillStyle = fillColor;
            ctx.fillRect(barX, barY, fillWidth, barHeight);
            
            // Right side: 4 stacked charts (Speed, Density, Bt, Bz) - shifted down for Kp panel
            const chartStartY = kpPanelHeight + 20;
            const adjustedChartHeight = (1200 - chartStartY) / 4;
            
            const rightCharts = [
                { id: 'chart-speed', x: mapWidth, y: chartStartY, height: adjustedChartHeight },
                { id: 'chart-density', x: mapWidth, y: chartStartY + adjustedChartHeight, height: adjustedChartHeight },
                { id: 'chart-bt', x: mapWidth, y: chartStartY + adjustedChartHeight * 2, height: adjustedChartHeight },
                { id: 'chart-bz', x: mapWidth, y: chartStartY + adjustedChartHeight * 3, height: adjustedChartHeight }
            ];
            
            // Bottom row: Magnetometer (left) and Hemispheric Power (right)
            const bottomCharts = [
                { id: 'chart-mag', x: 0, y: mapHeight, height: bottomHeight, width: mapWidth },
                { id: 'chart-power', x: mapWidth, y: mapHeight, height: bottomHeight, width: chartWidth }
            ];
            
            // Capture right side charts
            for (const chart of rightCharts) {
                try {
                    const chartEl = document.getElementById(chart.id);
                    if (chartEl && chartEl._fullLayout) {
                        const imgData = await Plotly.toImage(chartEl, {
                            format: 'png',
                            width: chartWidth,
                            height: chart.height
                        });
                        const img = await loadImage(imgData);
                        ctx.drawImage(img, chart.x, chart.y, chartWidth, chart.height);
                    }
                } catch (e) {
                    console.warn(`Failed to capture ${chart.id}:`, e);
                }
            }
            
            // Capture bottom row charts
            for (const chart of bottomCharts) {
                try {
                    const chartEl = document.getElementById(chart.id);
                    if (chartEl && chartEl._fullLayout) {
                        const imgData = await Plotly.toImage(chartEl, {
                            format: 'png',
                            width: chart.width,
                            height: chart.height
                        });
                        const img = await loadImage(imgData);
                        ctx.drawImage(img, chart.x, chart.y, chart.width, chart.height);
                    }
                } catch (e) {
                    console.warn(`Failed to capture ${chart.id}:`, e);
                }
            }
            
            // Add labels and values overlay
            ctx.font = 'bold 24px sans-serif';
            ctx.fillStyle = '#94a3b8';
            
            // Get Bz value and determine color/direction
            const bzValue = document.getElementById('chart-val-bz').textContent;
            const bzNumeric = parseFloat(bzValue);
            const bzDirection = bzNumeric >= 0 ? 'NORTH' : 'SOUTH';
            const bzColor = bzNumeric >= 0 ? '#4ade80' : '#ef4444';
            const bzDisplay = `${bzValue} ${bzDirection}`;
            
            // Chart labels and values for right side (using already defined chartStartY and adjustedChartHeight)
            const labels = [
                { text: 'SOLAR WIND SPEED', value: document.getElementById('chart-val-speed').textContent, x: mapWidth + 30, y: chartStartY + 30, color: '#f8fafc' },
                { text: 'PROTON DENSITY', value: document.getElementById('chart-val-density').textContent, x: mapWidth + 30, y: chartStartY + adjustedChartHeight + 30, color: '#f8fafc' },
                { text: 'IMF BT', value: document.getElementById('chart-val-bt').textContent, x: mapWidth + 30, y: chartStartY + adjustedChartHeight * 2 + 30, color: '#f8fafc' },
                { text: 'IMF BZ', value: bzDisplay, x: mapWidth + 30, y: chartStartY + adjustedChartHeight * 3 + 30, color: bzColor }
            ];
            
            labels.forEach(label => {
                // Draw label with Metropolis font
                ctx.fillStyle = '#94a3b8';
                ctx.font = 'bold 20px Metropolis, sans-serif';
                ctx.fillText(label.text, label.x, label.y);
                
                // Draw value (right aligned)
                ctx.fillStyle = label.color;
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(label.value, mapWidth + chartWidth - 30, label.y + 5);
                ctx.textAlign = 'left';
            });
            
            // Bottom row labels with Metropolis font
            ctx.fillStyle = '#94a3b8';
            ctx.font = 'bold 20px Metropolis, sans-serif';
            ctx.fillText('GOES MAGNETOMETER', 30, mapHeight + 30);
            ctx.fillText('HEMISPHERIC POWER', mapWidth + 30, mapHeight + 30);
            
            // Hemispheric power value
            const powerVal = document.getElementById('chart-val-power').textContent;
            ctx.fillStyle = '#f8fafc';
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(powerVal, width - 30, mapHeight + 35);
            ctx.textAlign = 'left';
            
            // Add logo (top left corner, small)
            try {
                const logo = await loadImage('/wtusredlogotransparentx.png');
                const logoHeight = 60; // Small size
                const logoWidth = (logo.width / logo.height) * logoHeight;
                ctx.globalAlpha = 0.8; // Slightly transparent
                ctx.drawImage(logo, 20, 20, logoWidth, logoHeight);
                ctx.globalAlpha = 1.0; // Reset opacity
            } catch (e) {
                console.warn('Failed to load logo:', e);
            }
            
            return canvas;
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        async function generateGif() {
            const btn = document.getElementById('generate-gif-btn');
            const progressBar = document.getElementById('gif-progress');
            const progressFill = document.getElementById('gif-progress-bar');
            const statusText = document.getElementById('gif-status-text');
            
            const hours = document.getElementById('gif-hours').value;
            const interval = document.getElementById('gif-interval').value;

            btn.disabled = true;
            btn.textContent = 'Generating...';
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
            statusText.textContent = 'Generating animation from historical data...';

            let progress = 0;
            const progressAnim = setInterval(() => {
                if (progress < 90) {
                    progress += 2;
                    progressFill.style.width = `${progress}%`;
                }
            }, 100);

            try {
                const response = await fetch(`/generate-gif?hours=${hours}&interval=${interval}&duration=500&mode=historical`);
                
                if (!response.ok) throw new Error('Generation failed');

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `aurora_historical_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.gif`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                clearInterval(progressAnim);
                progressFill.style.width = '100%';
                statusText.textContent = 'Download started! Generated instantly from historical data.';
                showToast('GIF generated successfully', 'success');

            } catch (error) {
                console.error(error);
                showToast('Failed to generate GIF', 'error');
                statusText.textContent = 'Error generating GIF';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Generate Animation';
                setTimeout(() => {
                    progressBar.style.display = 'none';
                    statusText.textContent = '';
                }, 5000);
            }
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const icon = document.getElementById('toast-icon');
            const msg = document.getElementById('toast-message');

            icon.textContent = type === 'success' ? '‚úÖ' : '‚ùå';
            msg.textContent = message;
            
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Aurora Probability Calculator
        async function updateAuroraProbability() {
            const latitude = document.getElementById('user-latitude').value;
            if (!latitude || latitude === '') {
                document.getElementById('prob-percentage').textContent = '--%';
                document.getElementById('prob-visibility').textContent = 'Enter your latitude';
                return;
            }

            try {
                const response = await fetch(`/api/aurora-probability?lat=${latitude}`);
                const data = await response.json();
                
                document.getElementById('prob-percentage').textContent = `${data.probability}%`;
                document.getElementById('prob-visibility').textContent = data.visibility;
                document.getElementById('prob-percentage').style.color = data.color;
                
                // Save to localStorage
                localStorage.setItem('userLatitude', latitude);
            } catch (error) {
                console.error('Error fetching aurora probability:', error);
            }
        }

        // Timezone functions
        let currentTimezone = 'UTC';

        function updateTimezone() {
            currentTimezone = document.getElementById('timezone-selector').value;
            localStorage.setItem('timezone', currentTimezone);
            
            // Update the UTC clock display immediately
            updateUtcTime();
        }

        function updateUtcTime() {
            const now = new Date();
            const timeElem = document.getElementById('utc-time');
            
            if (currentTimezone === 'UTC') {
                const hours = String(now.getUTCHours()).padStart(2, '0');
                const minutes = String(now.getUTCMinutes()).padStart(2, '0');
                timeElem.textContent = `${hours}:${minutes} UTC`;
            } else if (currentTimezone === 'local') {
                const hours = now.getHours();
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const hour12 = hours % 12 || 12;
                const ampm = hours >= 12 ? 'PM' : 'AM';
                
                // Get timezone abbreviation
                const tzString = now.toLocaleTimeString('en-US', { timeZoneName: 'short' });
                const tzAbbr = tzString.split(' ').pop();
                
                timeElem.textContent = `${hour12}:${minutes} ${ampm} ${tzAbbr}`;
            } else {
                try {
                    const tzDate = new Date(now.toLocaleString('en-US', { timeZone: currentTimezone }));
                    const hours = tzDate.getHours();
                    const minutes = String(tzDate.getMinutes()).padStart(2, '0');
                    const hour12 = hours % 12 || 12;
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    
                    // Get timezone abbreviation with DST support
                    const tzString = now.toLocaleTimeString('en-US', { 
                        timeZone: currentTimezone, 
                        timeZoneName: 'short' 
                    });
                    const tzAbbr = tzString.split(' ').pop();
                    
                    timeElem.textContent = `${hour12}:${minutes} ${ampm} ${tzAbbr}`;
                } catch (e) {
                    const hours = String(now.getUTCHours()).padStart(2, '0');
                    const minutes = String(now.getUTCMinutes()).padStart(2, '0');
                    timeElem.textContent = `${hours}:${minutes} UTC`;
                }
            }
        }

        function formatTimeInTimezone(isoString) {
            const date = new Date(isoString);
            
            if (currentTimezone === 'UTC') {
                return date.toISOString().slice(11, 16) + ' UTC';
            } else if (currentTimezone === 'local') {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else {
                try {
                    return date.toLocaleString('en-US', { 
                        timeZone: currentTimezone, 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                } catch (e) {
                    return date.toISOString().slice(11, 16) + ' UTC';
                }
            }
        }

        // Moon Phase Calculator
        function calculateMoonPhase() {
            const now = new Date();
            
            // Known new moon: January 11, 2024 at 11:57 UTC
            const knownNewMoon = new Date('2024-01-11T11:57:00Z');
            const lunarCycle = 29.53058867; // days
            
            // Calculate days since known new moon
            const daysSinceNew = (now - knownNewMoon) / (1000 * 60 * 60 * 24);
            const phase = ((daysSinceNew % lunarCycle) / lunarCycle);
            
            // Calculate illumination percentage
            const illumination = Math.abs(Math.cos(phase * 2 * Math.PI));
            const illuminationPercent = Math.round(illumination * 100);
            
            // Determine phase name and image
            let phaseName, moonImage, visibilityImpact;
            
            if (phase < 0.033 || phase > 0.967) {
                phaseName = 'New Moon';
                moonImage = 'new-moon.png';
                visibilityImpact = 'Excellent for aurora viewing - dark skies';
            } else if (phase < 0.216) {
                phaseName = 'Waxing Crescent';
                moonImage = 'waxing-crescent.png';
                visibilityImpact = 'Very good - minimal moonlight interference';
            } else if (phase < 0.283) {
                phaseName = 'First Quarter';
                moonImage = 'first-quarter.png';
                visibilityImpact = 'Good - moon sets around midnight';
            } else if (phase < 0.466) {
                phaseName = 'Waxing Gibbous';
                moonImage = 'waxing-gibbous.png';
                visibilityImpact = 'Fair - bright moon may reduce visibility';
            } else if (phase < 0.533) {
                phaseName = 'Full Moon';
                moonImage = 'full-moon.png';
                visibilityImpact = 'Poor - bright moonlight washes out aurora';
            } else if (phase < 0.716) {
                phaseName = 'Waning Gibbous';
                moonImage = 'waning-gibbous.png';
                visibilityImpact = 'Fair - moon rises late';
            } else if (phase < 0.783) {
                phaseName = 'Last Quarter';
                moonImage = 'last-quarter.png';
                visibilityImpact = 'Good - moon rises after midnight';
            } else {
                phaseName = 'Waning Crescent';
                moonImage = 'waning-crescent.png';
                visibilityImpact = 'Very good - moon rises near dawn';
            }
            
            // Update display
            const moonImgElem = document.getElementById('moon-image');
            if (moonImgElem) {
                // Use simple, reliable image URLs from a CDN
                const moonIcons = {
                    'new-moon.png': 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23333" stroke="%23999" stroke-width="2"/></svg>',
                    'waxing-crescent.png': 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23333" stroke="%23999" stroke-width="2"/><path d="M50,5 A45,45 0 0,1 50,95 A35,35 0 0,0 50,5" fill="%23ddd"/></svg>',
                    'first-quarter.png': 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23333" stroke="%23999" stroke-width="2"/><path d="M50,5 A45,45 0 0,1 50,95 Z" fill="%23ddd"/></svg>',
                    'waxing-gibbous.png': 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23ddd" stroke="%23999" stroke-width="2"/><path d="M50,5 A45,45 0 0,0 50,95 A15,15 0 0,1 50,5" fill="%23333"/></svg>',
                    'full-moon.png': 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23ddd" stroke="%23999" stroke-width="2"/></svg>',
                    'waning-gibbous.png': 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23ddd" stroke="%23999" stroke-width="2"/><path d="M50,5 A45,45 0 0,1 50,95 A15,15 0 0,0 50,5" fill="%23333"/></svg>',
                    'last-quarter.png': 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23333" stroke="%23999" stroke-width="2"/><path d="M50,5 A45,45 0 0,0 50,95 Z" fill="%23ddd"/></svg>',
                    'waning-crescent.png': 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23333" stroke="%23999" stroke-width="2"/><path d="M50,5 A45,45 0 0,0 50,95 A35,35 0 0,1 50,5" fill="%23ddd"/></svg>'
                };
                moonImgElem.src = moonIcons[moonImage] || moonIcons['new-moon.png'];
                moonImgElem.alt = phaseName;
                moonImgElem.onerror = function() {
                    console.error('Failed to load moon phase image');
                    this.style.display = 'none';
                };
            }
            document.getElementById('moon-phase-name').textContent = phaseName;
            document.getElementById('moon-illumination').textContent = `${illuminationPercent}% illuminated`;
            document.getElementById('moon-visibility-impact').textContent = visibilityImpact;
        }

        // Alert system
        function checkForAlerts(data) {
            const kp = data.kp_index || 0;
            const alertBanner = document.getElementById('alert-banner');
            const alertMessage = document.getElementById('alert-message');
            
            if (kp >= 5) {
                let level = 'G1 (Minor)';
                let color = '#f59e0b';
                
                if (kp >= 9) {
                    level = 'G5 (Extreme)';
                    color = '#dc2626';
                } else if (kp >= 8) {
                    level = 'G4 (Severe)';
                    color = '#ef4444';
                } else if (kp >= 7) {
                    level = 'G3 (Strong)';
                    color = '#f97316';
                } else if (kp >= 6) {
                    level = 'G2 (Moderate)';
                    color = '#fb923c';
                }
                
                alertMessage.textContent = `${level} geomagnetic storm in progress (Kp=${kp.toFixed(1)}). Aurora may be visible at lower latitudes.`;
                alertBanner.style.borderColor = color;
                alertBanner.style.display = 'block';
            } else {
                alertBanner.style.display = 'none';
            }
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const icon = document.getElementById('toast-icon');
            const msg = document.getElementById('toast-message');

            msg.textContent = message;
            icon.textContent = type === 'success' ? '‚úÖ' : '‚ùå';
            toast.className = `toast toast-${type} show`;

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        function toggleMobileMenu() {
            const navLinks = document.getElementById('nav-links');
            navLinks.classList.toggle('active');
        }
    </script>
</body>
</html>
