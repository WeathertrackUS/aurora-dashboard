<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>WTUS SpaceWx</title>
    <link rel="icon" href="/static/favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;700&family=Outfit:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        /* Local Metropolis fallback - requires font files in static/fonts/metropolis/ */
        @font-face {
            font-family: 'Metropolis';
            src: local('Metropolis'),
                 url('/static/fonts/metropolis/Metropolis-Regular.woff2') format('woff2'),
                 url('/static/fonts/metropolis/Metropolis-Regular.woff') format('woff'),
                 url('/static/fonts/metropolis/Metropolis-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Metropolis';
            src: local('Metropolis Bold'),
                 url('/static/fonts/metropolis/Metropolis-Bold.woff2') format('woff2'),
                 url('/static/fonts/metropolis/Metropolis-Bold.woff') format('woff'),
                 url('/static/fonts/metropolis/Metropolis-Bold.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }
    </style>
    <!-- ECharts for charting -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <style>
        :root {
            --bg-dark: #0a0a0a;
            --bg-card: #1a1a1a;
            --bg-card-hover: #222222;
            --text-primary: #e5e5e5;
            --text-secondary: #8b8b8b;
            --accent-primary: #666666;
            --accent-secondary: #888888;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: rgba(255, 255, 255, 0.06);
            --glass-border: 1px solid rgba(255, 255, 255, 0.06);
            --glass-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.6);
            --font-sans: 'Inter', 'Metropolis', system-ui, -apple-system, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-primary);
            font-family: var(--font-sans);
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            -webkit-tap-highlight-color: transparent;
            touch-action: pan-x pan-y;
        }

        /* Safe area insets for notched devices */
        @supports (padding: env(safe-area-inset-bottom)) {
            body {
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
            .navbar {
                padding-top: max(0.875rem, env(safe-area-inset-top));
            }
            footer {
                padding-bottom: max(2rem, env(safe-area-inset-bottom));
            }
        }

        /* New Dashboard Grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1.6fr 1fr;
            grid-template-rows: minmax(80px, 0.5fr) minmax(120px, 1fr) minmax(120px, 1fr) minmax(120px, 1fr) minmax(120px, 1fr) auto;
            gap: 0.5rem;
            width: 100%;
            max-width: 2400px;
            margin: 0 auto;
            padding: 0.5rem;
            min-height: calc(100vh - 60px);
        }
        
        .chart-panel {
            background: var(--bg-card);
            border: var(--glass-border);
            border-radius: 3px;
            padding: 0.25rem;
            min-height: 120px;
            height: 100%;
            position: relative;
            overflow: hidden;
            transition: background 0.2s ease;
            display: flex;
            flex-direction: column;
        }
        
        .chart-panel:hover {
            background: var(--bg-card-hover);
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .map-panel {
            grid-row: 1 / span 5;
            background: var(--bg-card);
            border: var(--glass-border);
            border-radius: 3px;
            padding: 0.25rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            position: relative;
        }
        
        .map-image {
            width: 100%;
            height: auto;
            max-height: 100%;
            object-fit: contain;
            border-radius: 2px;
        }
        
        .chart-container {
            width: 100%;
            height: calc(100% - 35px);
            min-height: 80px;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .chart-title {
            position: absolute;
            top: 8px;
            left: 10px;
            font-size: 0.7rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            z-index: 10;
            pointer-events: none;
            text-transform: uppercase;
            opacity: 0.6;
        }
        
        .chart-value {
            position: absolute;
            top: 6px;
            right: 10px;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
            z-index: 10;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(0,0,0,0.5);
            font-family: 'JetBrains Mono', monospace;
            background: rgba(15, 23, 42, 0.4);
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }

        @media (max-width: 1400px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
            .map-panel {
                grid-row: auto;
                min-height: 500px;
                max-height: 600px;
            }
            .chart-panel {
                min-height: 200px;
            }
            .chart-container {
                min-height: 160px;
            }
        }
        
        @media (max-width: 1024px) {
            .dashboard-grid {
                gap: 0.75rem;
            }
            .map-panel {
                min-height: 400px;
                max-height: 500px;
            }
            .chart-panel {
                min-height: 180px;
            }
            .chart-container {
                min-height: 140px;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Metropolis', 'Inter', sans-serif;
            background-color: var(--bg-dark);
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(56, 189, 248, 0.15) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(129, 140, 248, 0.15) 0%, transparent 20%),
                radial-gradient(circle at 50% 50%, rgba(168, 85, 247, 0.05) 0%, transparent 50%);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            position: relative;
        }

        /* Noise Texture */
        .bg-noise {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            opacity: 0.03;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        /* Tooltips */
        .tooltip-container {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: help;
            margin-left: 4px;
        }

        .info-icon {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1px solid var(--text-secondary);
            color: var(--text-secondary);
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .tooltip-container:hover .info-icon {
            color: var(--accent-primary);
            border-color: var(--accent-primary);
            background: rgba(56, 189, 248, 0.1);
        }

        .tooltip-content {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0.75rem;
            border-radius: 0.5rem;
            width: 200px;
            font-size: 0.75rem;
            color: var(--text-primary);
            text-transform: none;
            letter-spacing: normal;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 100;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            text-align: center;
            line-height: 1.4;
        }

        .tooltip-container:hover .tooltip-content {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-8px);
        }

        .tooltip-content::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(15, 23, 42, 0.95) transparent transparent transparent;
        }

        /* Navbar */
        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.875rem 2rem;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 1000;
            min-height: 56px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 0.625rem;
            font-weight: 600;
            font-size: 1.125rem;
            color: var(--text-primary);
            letter-spacing: -0.01em;
            text-decoration: none;
        }

        .brand span {
            font-size: 1.25rem;
        }

        .nav-links {
            display: flex;
            gap: 1.5rem;
            margin-left: 2rem;
            margin-right: auto;
            align-items: center;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            transition: color 0.2s;
        }

        .nav-link:hover {
            color: var(--accent-primary);
        }

        .nav-link.active {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .nav-stats {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .stat-value {
            color: var(--accent-primary);
            font-family: var(--font-mono);
            font-weight: 600;
        }

        /* Main Layout */
        .main-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 420px;
            gap: 1rem;
            padding: 1rem;
            max-width: 2400px;
            margin: 0 auto;
            width: 100%;
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        /* Dashboard Image Area */
        .dashboard-view {
            background: var(--bg-card);
            backdrop-filter: blur(12px);
            border-radius: 4px;
            border: var(--glass-border);
            overflow: hidden;
            position: relative;
            min-height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--glass-shadow);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .dashboard-view:hover {
            box-shadow: 0 20px 40px -5px rgba(0, 0, 0, 0.4);
        }

        .dashboard-image {
            width: 100%;
            height: auto;
            display: block;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .dashboard-image.loaded {
            opacity: 1;
        }

        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-width: 420px;
        }

        .card {
            background: var(--bg-card);
            backdrop-filter: blur(12px);
            border: var(--glass-border);
            border-radius: 4px;
            padding: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }
        
        .card:hover {
            transform: translateY(-2px);
            background: var(--bg-card-hover);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid var(--border);
            min-height: 28px;
            flex-wrap: wrap;
            gap: 0.5rem;
        }


        .card-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Live Data Grid */
        .data-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .data-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.75rem;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border: 1px solid transparent;
            transition: border-color 0.2s;
        }
        
        .data-item:hover {
            border-color: rgba(255, 255, 255, 0.1);
        }

        .data-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .data-icon {
            width: 16px;
            height: 16px;
            opacity: 0.7;
        }

        .data-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1;
        }
        
        .data-unit {
            font-size: 0.8rem;
            font-weight: 400;
            color: var(--text-secondary);
            margin-left: 2px;
        }

        .status-badge {
            grid-column: span 2;
            padding: 0.75rem;
            border-radius: 4px;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            background: rgba(56, 189, 248, 0.1);
            color: var(--accent-primary);
            border: 1px solid rgba(56, 189, 248, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.1);
            transition: all 0.3s ease;
        }

        .status-badge.pulse-active {
            animation: badge-pulse 2s infinite;
        }

        @keyframes badge-pulse {
            0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); }
            100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }

        .status-badge.pulse-warning {
            animation: badge-pulse-warning 2s infinite;
        }

        @keyframes badge-pulse-warning {
            0% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(251, 191, 36, 0); }
            100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0); }
        }

        /* Kp Meter */
        .kp-meter-container {
            grid-column: span 2;
            margin-top: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.5rem;
            padding: 0.75rem;
        }
        
        .kp-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
        
        .kp-track {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .kp-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4ade80, #fbbf24, #f87171);
            border-radius: 4px;
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .kp-ticks {
            display: flex;
            justify-content: space-between;
            margin-top: 4px;
            padding: 0 2px;
        }
        
        .kp-tick {
            width: 2px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
        }

        /* Controls */
        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        /* Time Range Selector for Dst Chart */
        .time-range-selector {
            display: flex;
            gap: 0.25rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.25rem;
            border-radius: 4px;
            flex-wrap: wrap;
        }

        .time-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.35rem 0.7rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: var(--font-sans);
        }

        .time-btn:hover {
            background: var(--bg-card-hover);
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }

        .time-btn.active {
            background: var(--accent-primary);
            color: var(--bg-dark);
            border-color: var(--accent-primary);
        }

        .btn {
            padding: 0.6rem 1rem;
            border-radius: 4px;
            border: none;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }
        
        .btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(255, 255, 255, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .btn:hover::after {
            opacity: 1;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), #0ea5e9);
            color: #0f172a;
            box-shadow: 0 4px 12px rgba(56, 189, 248, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(56, 189, 248, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .btn-full {
            grid-column: span 2;
        }

        /* Active Regions Table Styles */
        .regions-table {
            width: 100%;
            border-collapse: collapse;
            font-family: var(--font-mono);
            font-size: 0.75rem;
        }

        .regions-table th {
            text-align: left;
            padding: 0.5rem;
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 0.65rem;
            text-transform: uppercase;
            border-bottom: 1px solid var(--border);
        }

        .regions-table td {
            padding: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .regions-table tr:last-child td {
            border-bottom: none;
        }

        .regions-table tbody tr:hover {
            background-color: var(--bg-card-hover);
        }

        .region-number {
            font-weight: 700;
            color: var(--text-primary);
        }

        .region-mag-type {
            display: inline-block;
            padding: 0.15rem 0.35rem;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.05);
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .mag-alpha { color: #60a5fa; }
        .mag-beta { color: #34d399; }
        .mag-gamma { color: #fcd34d; }
        .mag-delta { color: #ef4444; }
        .mag-bgd { color: #ef4444; }

        .region-flare-badge {
            display: inline-block;
            padding: 0.1rem 0.25rem;
            border-radius: 2px;
            font-size: 0.65rem;
            font-weight: 700;
            margin-left: 0.25rem;
        }
        .flare-x { background-color: #ef4444; color: white; }
        .flare-m { background-color: #f59e0b; color: black; }
        .flare-c { background-color: #fbbf24; color: black; }

        .region-area {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            font-weight: 600;
        }
        .area-huge { color: #ec4899; }
        .area-large { color: #dc2626; }
        .area-medium { color: #f97316; }
        .area-small { color: #fbbf24; }
        .area-tiny { color: #22c55e; }

        /* GIF Generator */
        .form-group {
            margin-bottom: 1.25rem;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .form-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 0.875rem;
            color: var(--text-primary);
            font-family: inherit;
            transition: all 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.1);
        }

        .progress-container {
            margin-top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 999px;
            height: 6px;
            overflow: hidden;
            display: none;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }

        /* Footer */
        footer {
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            padding: 2rem;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: auto;
            background: rgba(15, 23, 42, 0.4);
        }

        /* Utilities */
        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--accent-primary);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 1.5rem;
            border-radius: 4px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 50;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast-success { border-left: 4px solid var(--success); }
        .toast-error { border-left: 4px solid var(--danger); }

        /* Geomagnetic Forecast Styles */
        .forecast-day {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .forecast-date {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .forecast-bar-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .forecast-bar {
            width: 100%;
            height: 120px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        .forecast-fill {
            width: 100%;
            border-radius: 4px;
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1rem;
            color: white;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .forecast-fill.g0 {
            background: linear-gradient(to top, #4ade80, #22c55e);
            height: 16.67%;
        }

        .forecast-fill.g1 {
            background: linear-gradient(to top, #fbbf24, #f59e0b);
            height: 33.33%;
        }

        .forecast-fill.g2 {
            background: linear-gradient(to top, #fb923c, #f97316);
            height: 50%;
        }

        .forecast-fill.g3 {
            background: linear-gradient(to top, #ef4444, #dc2626);
            height: 66.67%;
        }

        .forecast-fill.g4 {
            background: linear-gradient(to top, #dc2626, #b91c1c);
            height: 83.33%;
        }

        .forecast-fill.g5 {
            background: linear-gradient(to top, #991b1b, #7f1d1d);
            height: 100%;
        }

        .forecast-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-top: 0.25rem;
        }

        .forecast-kp {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-family: var(--font-mono);
        }

        .forecast-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .forecast-legend {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.7rem;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        /* Pulse Dot Animation */
        @keyframes pulse-dot {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.85; }
            100% { opacity: 1; }
        }

        /* Mobile Menu Toggle - hidden on desktop */
        .mobile-menu-toggle {
            display: none !important;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            z-index: 1001;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .navbar {
                padding: 0.75rem 1rem;
                flex-wrap: wrap;
                position: sticky;
                top: 0;
                z-index: 1000;
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            }
            
            .mobile-menu-toggle {
                display: block;
                padding: 0.5rem;
                min-width: 44px;
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .brand {
                font-size: 0.95rem;
                flex: 1;
                min-width: 0;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            .brand span {
                font-size: 1rem;
            }
            
            .nav-links {
                display: none;
                width: 100%;
                margin: 1rem 0 0 0;
                flex-direction: column;
                gap: 0.5rem;
                background: var(--bg-card);
                padding: 0.75rem;
                border-radius: 0.5rem;
                border: 1px solid var(--border);
                order: 3;
            }
            
            .nav-links.active {
                display: flex;
            }
            
            .nav-link {
                font-size: 1rem;
                padding: 0.75rem;
                min-height: 44px;
                display: flex;
                align-items: center;
                border-radius: 4px;
                transition: background 0.2s;
            }
            
            .nav-link:active {
                background: rgba(255, 255, 255, 0.1);
            }
            
            .nav-stats {
                gap: 0.75rem;
            }
            
            .stat-item {
                font-size: 0.75rem;
            }
            
            .main-container {
                padding: 0.5rem;
                gap: 0.5rem;
                display: flex;
                flex-direction: column;
            }
            
            .dashboard-grid {
                padding: 0.5rem;
                gap: 0.75rem;
                display: flex;
                flex-direction: column;
                min-height: auto;
            }
            
            .chart-panel {
                border-radius: 6px;
                min-height: 160px;
                height: auto !important;
                padding: 0.5rem;
                position: relative;
            }
            
            .chart-container {
                height: 130px !important;
                min-height: 130px !important;
                max-height: none;
                position: relative !important;
                bottom: auto !important;
                left: auto !important;
                right: auto !important;
                margin-top: 30px;
            }
            
            .sidebar {
                width: 100%;
                max-width: 100%;
                min-width: auto;
            }
            
            .card {
                margin-bottom: 0.75rem;
            }
            
            /* Better touch targets */
            button, .btn, select, input {
                min-height: 44px;
                font-size: 1rem;
                touch-action: manipulation;
            }
            
            select {
                padding: 0.75rem;
                appearance: none;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%238b8b8b' viewBox='0 0 16 16'%3E%3Cpath d='M7.247 11.14L2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
                background-repeat: no-repeat;
                background-position: right 0.75rem center;
                padding-right: 2.5rem;
            }
            
            .map-panel {
                border-radius: 6px;
                min-height: 280px;
                max-height: none;
                height: auto;
                aspect-ratio: 1;
                padding-top: 2rem; /* Space for title */
            }
            
            .map-panel .chart-title {
                font-size: 0.7rem;
                top: 6px;
                left: 8px;
                max-width: none;
                background: rgba(10, 10, 10, 0.7);
                padding: 2px 6px;
                border-radius: 3px;
                z-index: 20;
            }
            
            .chart-title {
                font-size: 0.65rem;
                top: 8px;
                left: 8px;
                max-width: 50%;
            }
            
            .chart-value {
                font-size: 0.95rem;
                top: 6px;
                right: 8px;
                padding: 0.15rem 0.35rem;
            }
            
            /* Fix data grid on mobile */
            .data-grid {
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }
            
            .data-value {
                font-size: 1.2rem;
            }
            
            /* Forecast grid mobile */
            .forecast-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.5rem;
            }
            
            .forecast-bar {
                height: 100px;
            }
            
            .forecast-fill {
                font-size: 0.9rem;
            }
            
            /* Time range selector mobile */
            .time-range-selector {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .time-btn {
                min-height: 36px;
                padding: 0.4rem 0.6rem;
                font-size: 0.75rem;
            }
            
            /* Control grid mobile */
            .control-grid {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .btn-full {
                grid-column: span 1;
            }
            
            /* Toast positioning */
            .toast {
                bottom: 1rem;
                right: 1rem;
                left: 1rem;
                width: auto;
            }
            
            /* Regions table mobile */
            .regions-table {
                font-size: 0.7rem;
            }
            
            .regions-table th {
                font-size: 0.6rem;
                padding: 0.4rem 0.3rem;
            }
            
            .regions-table td {
                padding: 0.4rem 0.3rem;
            }
            
            .region-mag-type {
                font-size: 0.65rem;
                padding: 0.1rem 0.25rem;
            }
            
            .region-flare-badge {
                font-size: 0.6rem;
                padding: 0.05rem 0.2rem;
            }
        }
        
        @media (max-width: 480px) {
            .navbar {
                flex-wrap: wrap;
                padding: 0.5rem 0.5rem;
            }
            
            .brand {
                font-size: 0.85rem;
                flex: 1;
                min-width: 0;
            }
            
            /* Hide BETA badge on small screens */
            .brand > span[style*="BETA"] {
                display: none !important;
            }
            
            .nav-links {
                order: 3;
                width: 100%;
                margin: 0.5rem 0 0 0;
                gap: 0.5rem;
            }
            
            .nav-stats {
                margin-left: auto;
                gap: 0.5rem;
            }
            
            .stat-item span:first-child {
                display: none;
            }
            
            .main-container {
                padding: 0.25rem;
            }
            
            .dashboard-grid {
                padding: 0.25rem;
                gap: 0.5rem;
            }
            
            .chart-panel {
                min-height: 150px;
                padding: 0.4rem;
                border-radius: 6px;
            }
            
            .map-panel {
                min-height: 260px;
                max-height: none;
                aspect-ratio: 1;
                padding-top: 1.75rem;
            }
            
            .map-panel .chart-title {
                font-size: 0.6rem;
                top: 4px;
                left: 6px;
            }
            
            .chart-container {
                height: 110px !important;
                min-height: 110px !important;
                margin-top: 28px;
            }
            
            .chart-title {
                font-size: 0.6rem;
                top: 6px;
                left: 6px;
            }
            
            .chart-value {
                font-size: 0.85rem;
                top: 4px;
                right: 6px;
                padding: 0.1rem 0.25rem;
            }
            
            /* Stack sidebar items more compactly */
            .sidebar .card {
                margin-bottom: 0.5rem;
                padding: 0.5rem;
            }
            
            .card-header {
                margin-bottom: 0.5rem;
                padding-bottom: 0.35rem;
            }
            
            .card-title {
                font-size: 0.85rem;
            }
            
            /* Forecast grid compact */
            .forecast-grid {
                gap: 0.35rem;
            }
            
            .forecast-day {
                min-height: auto;
            }
            
            .forecast-date {
                font-size: 0.65rem;
            }
            
            .forecast-bar {
                height: 80px;
            }
            
            .forecast-fill {
                font-size: 0.8rem;
            }
            
            .forecast-kp {
                font-size: 0.6rem;
            }
            
            .forecast-legend {
                gap: 0.5rem;
                font-size: 0.6rem;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .legend-color {
                width: 10px;
                height: 10px;
            }
            
            /* Improve moon phase card */
            #moon-image {
                width: 65px !important;
                height: 65px !important;
            }
            
            /* Kp meter on mobile */
            .kp-meter-container {
                padding: 0.5rem;
            }
            
            .kp-label {
                font-size: 0.7rem;
            }
            
            /* Data items spacing */
            .data-item {
                padding: 0.5rem;
            }
            
            /* Toast on mobile */
            .toast {
                left: 0.5rem;
                right: 0.5rem;
                bottom: 0.5rem;
                font-size: 0.85rem;
            }
            
            /* Footer compact */
            footer {
                padding: 1.25rem 0.75rem;
                font-size: 0.8rem;
            }
        }
        
        /* Touch-specific improvements */
        @media (hover: none) and (pointer: coarse) {
            /* Larger touch targets */
            button, .btn, a, .nav-link, .tab-btn, .time-btn {
                min-height: 44px;
                min-width: 44px;
            }
            
            /* Prevent text selection on interactive elements */
            button, .btn, .nav-link, .tab-btn {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
            }
            
            /* Smoother scrolling */
            .main-container, .sidebar, .dashboard-grid {
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
            }
            
            /* Disable hover effects on touch */
            .card:hover {
                transform: none;
            }
            
            .chart-panel:hover {
                background: var(--bg-card);
                border-color: rgba(255, 255, 255, 0.06);
            }
            
            /* Active states for touch feedback */
            button:active, .btn:active, .time-btn:active {
                opacity: 0.8;
                transform: scale(0.98);
            }
            
            /* Prevent zoom on double tap for form elements */
            input, select, textarea {
                font-size: 16px !important;
            }
            
            /* Improve chart interactions */
            .chart-container {
                touch-action: pan-x pan-y;
            }
        }
        
        /* Landscape orientation fixes */
        @media (max-height: 500px) and (orientation: landscape) {
            .navbar {
                padding: 0.5rem 1rem;
            }
            
            .map-panel {
                min-height: 200px;
                max-height: 60vh;
            }
            
            .chart-panel {
                min-height: 120px;
            }
            
            .chart-container {
                height: 90px !important;
                min-height: 90px !important;
            }
        }

        /* System alert link styles: brighter blue/purple for visibility */
        #system-alert-banner a,
        #system-alert-banner a:visited {
            color: #6C63FF; /* bright blue/purple */
            text-decoration: underline;
            font-weight: 600;
        }

        #system-alert-banner a:hover,
        #system-alert-banner a:focus {
            color: #9FA8FF;
            text-decoration: underline;
            outline: none;
        }
        
        /* Bottom charts panel - responsive grid */
        .bottom-charts-panel {
            min-height: 240px;
        }
        
        .bottom-charts-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 0.5rem;
            height: 100%;
            min-height: 200px;
        }
        
        .mag-chart-wrapper,
        .power-chart-wrapper {
            position: relative;
            min-height: 180px;
        }
        
        .substorm-badge {
            margin-left: 15px;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: bold;
            background: #1e293b;
            border: 2px solid #10b981;
            color: #10b981;
            white-space: nowrap;
            vertical-align: middle;
        }
        
        /* Magnetometer chart title with badge - flex container */
        .mag-chart-wrapper .chart-title {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        /* Dst chart container */
        .dst-chart-container {
            width: 100%;
            height: 180px;
        }
        
        @media (max-width: 768px) {
            .bottom-charts-panel {
                min-height: auto;
            }
            
            .bottom-charts-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .mag-chart-wrapper,
            .power-chart-wrapper {
                min-height: 160px;
            }
            
            .mag-chart-wrapper .chart-container,
            .power-chart-wrapper .chart-container {
                height: 130px !important;
                min-height: 130px !important;
            }
            
            .substorm-badge {
                display: inline-block;
                margin-left: 0;
                margin-top: 0;
                text-align: center;
                font-size: 0.65rem;
                padding: 2px 6px;
                flex-shrink: 0;
            }
            
            .mag-chart-wrapper .chart-title {
                font-size: 0.6rem;
                flex-direction: row;
                flex-wrap: nowrap;
                gap: 6px;
                max-width: 100%;
                overflow: hidden;
            }
            
            .dst-chart-container {
                height: 160px;
            }
        }
        
        @media (max-width: 480px) {
            .mag-chart-wrapper,
            .power-chart-wrapper {
                min-height: 140px;
            }
            
            .mag-chart-wrapper .chart-container,
            .power-chart-wrapper .chart-container {
                height: 110px !important;
                min-height: 110px !important;
            }
            
            .dst-chart-container {
                height: 140px;
            }

            .substorm-badge {
                font-size: 0.55rem;
                padding: 2px 4px;
            }
            
            .mag-chart-wrapper .chart-title {
                font-size: 0.55rem;
            }
        }
    </style>
</head>
<body>
    <div class="bg-noise"></div>
    <nav class="navbar">
        <a href="/" class="brand">
            <span></span> WTUS Space Weather Dashboard
        </a>
        <button class="mobile-menu-toggle" onclick="toggleMobileMenu()" aria-label="Toggle menu">
            â˜°
        </button>
        <div class="nav-links" id="nav-links">
            <a href="/" class="nav-link active">Geomagnetic Activity</a>
            <a href="/solar" class="nav-link">Solar Activity</a>
            <a href="/historical" class="nav-link">Historical Data</a>
        </div>
        <div class="nav-stats">
            <div class="stat-item">
                <span>Time:</span>
                <span class="stat-value" id="utc-time">--:--</span>
            </div>
        </div>
    </nav>

    <!-- System Alerts Container (supports multiple alerts). Individual banners are created by JS. -->
    <div id="system-alerts-container" style="margin: 0.5rem 1rem;"></div>

    <!-- Legacy single-banner kept as a hidden template for compatibility -->
    <div id="system-alert-banner" style="display: none; border-radius: 3px; padding: 0.75rem 1rem;">
        <div style="display: flex; align-items: center; gap: 0.75rem;">
            <span data-template="icon" style="font-size: 1.5rem;"></span>
            <div style="flex: 1;">
                <div data-template="title" style="font-weight: 600; margin-bottom: 0.25rem;">System Notice</div>
                <div data-template="message" style="color: #e5e5e5; font-size: 0.9rem;"></div>
            </div>
            <button data-template="close" style="background: none; border: none; color: #8b8b8b; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem;">&times;</button>
        </div>
    </div>

    <!-- Geomagnetic Storm Alert Banner (hidden by default) -->
    <div id="alert-banner" style="display: none; background: rgba(239, 68, 68, 0.12); border: 1px solid #ef4444; border-radius: 3px; padding: 0.75rem 1rem; margin: 0.5rem 1rem; animation: pulse 2s ease-in-out infinite;">
        <div style="display: flex; align-items: center; gap: 0.75rem;">
            <span style="font-size: 1.5rem;"></span>
            <div style="flex: 1;">
                <div style="font-weight: 600; color: #ef4444; margin-bottom: 0.25rem;">Geomagnetic Storm Alert</div>
                <div id="alert-message" style="color: #e5e5e5; font-size: 0.9rem;"></div>
            </div>
            <button onclick="document.getElementById('alert-banner').style.display='none'" style="background: none; border: none; color: #8b8b8b; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem;">&times;</button>
        </div>
    </div>

    <main class="main-container">
        <!-- Left Column: Main Visualization -->
        <div class="dashboard-grid">
            <!-- Map Panel -->
            <div class="map-panel">
                <div class="chart-title" style="font-size: 1.1rem; color: var(--accent-primary); top: 20px; left: 20px;">AURORAL OVAL</div>
                <div class="loading-overlay" id="loading-overlay">
                    <div class="spinner"></div>
                    <p>Updating Data...</p>
                </div>
                <img src="/aurora-map.png" alt="Aurora Map" class="map-image" id="map-image">
            </div>
            
            <!-- Charts Column -->
            <div class="chart-panel">
                <div class="chart-title">PLANETARY K-INDEX</div>
                <div class="chart-value" id="kp-value-text">--</div>
                <div style="height: 100%; display: flex; flex-direction: column; justify-content: center; padding-top: 1.25rem;">
                     <div id="g-scale-display" style="text-align: center; margin-bottom: 0.5rem; font-family: 'JetBrains Mono', monospace; font-weight: 700; font-size: 1.2rem; color: var(--text-secondary); opacity: 0.5; line-height: 1;">
                        G0 <span style="font-size: 0.7rem; font-weight: 400; opacity: 0.7;">STORM SCALE</span>
                     </div>
                     <div class="kp-track" style="height: 10px; background: rgba(255,255,255,0.1); border-radius: 2px;">
                         <div class="kp-fill" id="kp-fill" style="border-radius: 2px;"></div>
                     </div>
                     <div class="kp-ticks" style="margin-top: 4px;">
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                        <div class="kp-tick"></div>
                     </div>
                </div>
            </div>

            <div class="chart-panel">
                <div class="chart-title">SOLAR WIND SPEED</div>
                <div class="chart-value" id="chart-val-speed">--</div>
                <div id="chart-speed" class="chart-container"></div>
            </div>
            
            <div class="chart-panel">
                <div class="chart-title">PROTON DENSITY</div>
                <div class="chart-value" id="chart-val-density">--</div>
                <div id="chart-density" class="chart-container"></div>
            </div>
            
            <div class="chart-panel">
                <div class="chart-title">IMF Bt</div>
                <div class="chart-value" id="chart-val-bt">--</div>
                <div id="chart-bt" class="chart-container"></div>
            </div>
            
            <div class="chart-panel">
                <div class="chart-title">IMF Bz</div>
                <div class="chart-value" id="chart-val-bz">--</div>
                <div id="chart-bz" class="chart-container"></div>
            </div>
            
            <!-- Bottom Row: Magnetometer & Power -->
            <div class="chart-panel bottom-charts-panel" style="grid-column: 1 / -1;">
                <div class="bottom-charts-grid">
                    <div class="mag-chart-wrapper">
                        <div class="chart-title">GOES MAGNETOMETER
                            <span id="substorm-badge" class="substorm-badge">SUBSTORM: INACTIVE</span>
                        </div>
                        <div id="chart-mag" class="chart-container"></div>
                    </div>
                    <div class="power-chart-wrapper">
                        <div class="chart-title">HEMISPHERIC POWER</div>
                        <div class="chart-value" id="chart-val-power">--</div>
                        <div id="chart-power" class="chart-container"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column: Sidebar -->
        <aside class="sidebar">
            <!-- Dst Index Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Dst Index</div>
                    <div class="time-range-selector">
                        <button class="time-btn" data-range="6h" onclick="setDstRange('6h')">6h</button>
                        <button class="time-btn" data-range="12h" onclick="setDstRange('12h')">12h</button>
                        <button class="time-btn active" data-range="24h" onclick="setDstRange('24h')">24h</button>
                        <button class="time-btn" data-range="3d" onclick="setDstRange('3d')">3d</button>
                        <button class="time-btn" data-range="7d" onclick="setDstRange('7d')">7d</button>
                    </div>
                </div>
                <div style="padding: 0.5rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4rem;">
                        <div>
                            <div style="font-size: 1.5rem; font-weight: 700; font-family: var(--font-mono); color: var(--text-primary);" id="chart-val-dst">--</div>
                            <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 0.05rem;">Storm Time Index</div>
                        </div>
                        <div style="font-size: 0.6rem; color: var(--text-secondary); line-height: 1.2; text-align: right;">
                            <div><span style="color: #22c55e;">â–¸</span> Quiet</div>
                            <div><span style="color: #fbbf24;">â–¸</span> Minor</div>
                            <div><span style="color: #f97316;">â–¸</span> Storm</div>
                        </div>
                    </div>
                    <div id="chart-dst" class="dst-chart-container"></div>
                </div>
            </div>
            
            <!-- Geomagnetic Forecast Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">3-Day Geomagnetic Forecast</div>
                </div>
                <div id="geomag-forecast-container" style="padding: 0.4rem;">
                    <p style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 0.4rem; font-size: 0.85rem;">Loading forecast...</p>
                </div>
            </div>

            <!-- Controls Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Aurora Visibility</div>
                </div>
                <div style="padding: 0.4rem;">
                    <div style="margin-bottom: 0.4rem;">
                        <label style="display: block; margin-bottom: 0.25rem; color: var(--text-secondary); font-size: 0.75rem;">Your Latitude</label>
                        <input type="number" id="user-latitude" placeholder="e.g., 45.5" step="0.1" min="-90" max="90" 
                               style="width: 100%; padding: 0.35rem; background: var(--bg-card); border: 1px solid var(--border); border-radius: 3px; color: var(--text-primary); font-family: var(--font-mono); font-size: 0.85rem;"
                               onchange="updateAuroraProbability()">
                    </div>
                    <div id="aurora-prob-display" style="text-align: center; padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 3px; border: 1px solid var(--border);">
                        <div style="font-size: 1.5rem; font-weight: 700; font-family: var(--font-mono); margin-bottom: 0.25rem;" id="prob-percentage">--%</div>
                        <div style="font-size: 0.75rem; color: var(--text-secondary);" id="prob-visibility">Enter your latitude</div>
                    </div>
                </div>
            </div>

            <!-- Timezone Selector Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Display Settings</div>
                </div>
                <div style="padding: 0.4rem;">
                    <label style="display: block; margin-bottom: 0.25rem; color: var(--text-secondary); font-size: 0.75rem;">Timezone</label>
                    <select id="timezone-selector" onchange="updateTimezone()" 
                            style="width: 100%; padding: 0.35rem; background: var(--bg-card); border: 1px solid var(--border); border-radius: 3px; color: var(--text-primary); font-family: var(--font-sans); font-size: 0.85rem;">
                        <option value="UTC">UTC (Universal Time)</option>
                        <option value="local">Local Time</option>
                        <option value="America/New_York">Eastern Time</option>
                        <option value="America/Chicago">Central Time</option>
                        <option value="America/Denver">Mountain Time</option>
                        <option value="America/Los_Angeles">Pacific Time</option>
                        <option value="America/Anchorage">Alaska Time</option>
                        <option value="Pacific/Honolulu">Hawaii Time</option>
                    </select>
                </div>
            </div>

            <!-- Moon Phase Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Current Moon Phase</div>
                </div>
                <div style="padding: 0.5rem; text-align: center;">
                    <img id="moon-image" src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23333' stroke='%23999' stroke-width='2'/></svg>" alt="Moon Phase" style="width: 75px; height: 75px; margin-bottom: 0.3rem;">
                    <div style="font-weight: 600; margin-bottom: 0.15rem; color: var(--text-primary); font-size: 0.9rem;" id="moon-phase-name">New Moon</div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.4rem;" id="moon-illumination">0% illuminated</div>
                    <div style="font-size: 0.7rem; color: var(--text-secondary); padding: 0.3rem; background: rgba(255,255,255,0.03); border-radius: 3px; line-height: 1.3;" id="moon-visibility-impact"></div>
                </div>
            </div>

            <!-- Controls Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Controls</div>
                </div>
                <div class="control-grid">
                    <button class="btn btn-primary btn-full" onclick="refreshDashboard()">
                         Refresh Now
                    </button>
                    <button class="btn btn-secondary" id="download-btn" onclick="downloadDashboard()">
                         Download
                    </button>
                    <button class="btn btn-secondary" onclick="copyImageToClipboard()">
                         Copy
                    </button>
                </div>
            </div>

        </aside>
    </main>
    <footer>
        <p>Data provided by NOAA Space Weather Prediction Center</p>
        <p style="margin-top: 0.5rem; opacity: 0.6;">&copy; 2026 Weather Track US</p>
    </footer>

    <div class="toast" id="toast">
        <span id="toast-icon"></span>
        <span id="toast-message">Operation successful</span>
    </div>

    <script>
        // State
        let nextRefreshTime = Date.now() + 60000;
        let refreshTimer;
        let countdownTimer;
        let isMobile = window.innerWidth <= 768;
        let isResizing = false;
        let resizeDebounceTimer = null;

        // Elements
        const mapImage = document.getElementById('map-image');
        const loadingOverlay = document.getElementById('loading-overlay');
        
        // Mobile detection helper
        function checkMobile() {
            isMobile = window.innerWidth <= 768;
            return isMobile;
        }
        
        // Debounced resize handler
        function handleResize() {
            if (resizeDebounceTimer) {
                clearTimeout(resizeDebounceTimer);
            }
            isResizing = true;
            resizeDebounceTimer = setTimeout(() => {
                isResizing = false;
                checkMobile();
                resizeAllCharts();
            }, 250);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            checkMobile();
            
            // Show loading overlay immediately for initial map load
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.classList.add('active');
            }
            
            // Preload the initial map image with retry logic
            const mapImage = document.getElementById('map-image');
            if (mapImage) {
                // Hide the img initially to prevent flash of broken image
                mapImage.style.opacity = '0';
                
                const initialLoad = async () => {
                    const src = `/aurora-map.png?t=${Date.now()}`;
                    for (let attempt = 0; attempt < 3; attempt++) {
                        try {
                            await new Promise((resolve, reject) => {
                                const img = new Image();
                                const timeout = setTimeout(() => reject(new Error('timeout')), 15000);
                                img.onload = () => { clearTimeout(timeout); resolve(); };
                                img.onerror = () => { clearTimeout(timeout); reject(new Error('load error')); };
                                img.src = src;
                            });
                            mapImage.src = src;
                            mapImage.style.opacity = '1';
                            console.log('Initial map loaded successfully');
                            return;
                        } catch (e) {
                            console.warn(`Initial map load attempt ${attempt + 1} failed:`, e.message);
                            if (attempt < 2) await new Promise(r => setTimeout(r, 1000 * (attempt + 1)));
                        }
                    }
                    // Still show the img even if loading failed
                    mapImage.style.opacity = '1';
                };
                initialLoad();
            }
            
            // Add resize listener
            window.addEventListener('resize', handleResize);
            window.addEventListener('orientationchange', () => {
                // Delay to let orientation change complete
                setTimeout(handleResize, 100);
            });
            
            refreshDashboard();
            startTimers();
            
            // Fetch solar regions
            fetchSolarRegions();
            // Refresh solar regions every 15 minutes
            setInterval(fetchSolarRegions, 15 * 60 * 1000);
            
            // Check for system alerts
            checkSystemAlert();
            // Re-check system alerts every 5 minutes
            setInterval(checkSystemAlert, 5 * 60 * 1000);
            
            // Load saved settings
            const savedLat = localStorage.getItem('userLatitude');
            if (savedLat) {
                document.getElementById('user-latitude').value = savedLat;
                updateAuroraProbability();
            }
            
            const savedTz = localStorage.getItem('timezone');
            if (savedTz) {
                document.getElementById('timezone-selector').value = savedTz;
                currentTimezone = savedTz;
            }
            
            // Initialize moon phase
            calculateMoonPhase();
            
            // Update time displays
            updateUtcTime();
            setInterval(updateUtcTime, 1000);
            
            // Update moon phase daily
            setInterval(calculateMoonPhase, 3600000); // Update every hour
            
            // Handle visibility change to refresh on tab return
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    // Resize charts when tab becomes visible again
                    setTimeout(resizeAllCharts, 100);
                }
            });
        });

        function updateUtcTime() {
            const now = new Date();
            const el = document.getElementById('utc-time');
            if (el) {
                el.textContent = now.toISOString().slice(11, 16) + ' UTC';
            }
        }

        function startTimers() {
            // Countdown timer
            countdownTimer = setInterval(() => {
                const now = Date.now();
                const diff = Math.ceil((nextRefreshTime - now) / 1000);
                const countdownEl = document.getElementById('countdown');
                
                if (countdownEl) {
                    if (diff <= 0) {
                        countdownEl.textContent = 'Refreshing...';
                    } else {
                        countdownEl.textContent = `${diff}s`;
                    }
                }
            }, 1000);

            // Auto refresh timer
            refreshTimer = setInterval(refreshDashboard, 60000);
            
            // Fetch Dst data
            currentDstRange = '24h';
            fetchDstData();
            setInterval(fetchDstData, 5 * 60 * 1000);  // Update every 5 minutes
        }
        
        let currentDstRange = '24h';
        
        function setDstRange(range) {
            currentDstRange = range;
            // Update active button state
            document.querySelectorAll('.time-range-selector .time-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.time-range-selector .time-btn[data-range="${range}"]`).classList.add('active');
            // Fetch new data
            fetchDstData();
        }
        
        async function fetchDstData() {
            try {
                const response = await fetch(`/api/dst-index?range=${currentDstRange}`);
                const data = await response.json();
                if (data.dst_values && data.dst_values.length > 0) {
                    plotDstChart(data.dst_values);
                }
            } catch (error) {
                console.error('Error fetching Dst data:', error);
            }
        }
        
        // ECharts instances storage
        window.echartsInstances = window.echartsInstances || {};
        
        function plotDstChart(dstData) {
            const times = dstData.map(d => d.time);
            const values = dstData.map(d => d.dst);
            
            // Update current value display
            if (values.length > 0) {
                const currentDst = values[values.length - 1];
                const dstEl = document.getElementById('chart-val-dst');
                dstEl.textContent = currentDst.toFixed(0) + ' nT';
                
                // Color code based on severity
                if (currentDst <= -100) {
                    dstEl.style.color = '#dc2626';
                } else if (currentDst <= -50) {
                    dstEl.style.color = '#f97316';
                } else if (currentDst <= -20) {
                    dstEl.style.color = '#fbbf24';
                } else {
                    dstEl.style.color = '#22c55e';
                }
            }
            
            const container = document.getElementById('chart-dst');
            if (window.echartsInstances['chart-dst']) {
                window.echartsInstances['chart-dst'].dispose();
            }
            const chart = echarts.init(container);
            window.echartsInstances['chart-dst'] = chart;
            
            // Calculate Y axis range
            const minDst = Math.min(...values, -50);
            const maxDst = Math.max(...values, 50);
            const yMin = Math.min(minDst - 20, -100);
            const yMax = Math.max(maxDst + 20, 50);
            
            // Normalize function to map Dst values to gradient positions (0 = bottom, 1 = top)
            // Note: More negative Dst = more severe storm = should be red (at bottom of chart)
            function normalizeDst(val) {
                return Math.max(0, Math.min(1, (val - yMin) / (yMax - yMin)));
            }
            
            const option = {
                backgroundColor: 'transparent',
                grid: {
                    left: 38,
                    right: 5,
                    top: 5,
                    bottom: 25
                },
                xAxis: {
                    type: 'category',
                    data: times.map(t => {
                        const d = new Date(t);
                        return d.getUTCHours().toString().padStart(2, '0') + ':' + d.getUTCMinutes().toString().padStart(2, '0');
                    }),
                    axisLine: { lineStyle: { color: '#444' } },
                    axisLabel: { color: '#8b8b8b', fontSize: 8 },
                    splitLine: { show: false }
                },
                yAxis: {
                    type: 'value',
                    min: yMin,
                    max: yMax,
                    axisLine: { lineStyle: { color: '#444' } },
                    axisLabel: { color: '#8b8b8b', fontSize: 8 },
                    splitLine: { lineStyle: { color: 'rgba(255,255,255,0.1)' } }
                },
                series: [{
                    type: 'line',
                    data: values,
                    smooth: true,
                    symbol: 'none',
                    lineStyle: {
                        color: '#60a5fa',
                        width: 2
                    },
                    areaStyle: {
                        // Gradient from bottom (red/severe) to top (blue/quiet)
                        // Dst thresholds: -100 (severe), -50 (moderate), -20 (minor), 0+ (quiet)
                        color: new echarts.graphic.LinearGradient(0, 1, 0, 0, [
                            { offset: 0, color: 'rgba(220, 38, 38, 0.5)' },
                            { offset: normalizeDst(-100), color: 'rgba(220, 38, 38, 0.5)' },
                            { offset: normalizeDst(-50), color: 'rgba(249, 115, 22, 0.4)' },
                            { offset: normalizeDst(-20), color: 'rgba(251, 191, 36, 0.3)' },
                            { offset: normalizeDst(0), color: 'rgba(96, 165, 250, 0.2)' },
                            { offset: 1, color: 'rgba(96, 165, 250, 0.1)' }
                        ])
                    },
                    markLine: {
                        silent: true,
                        symbol: 'none',
                        data: [
                            { yAxis: 0, lineStyle: { color: 'rgba(255,255,255,0.3)', width: 1 }, label: { show: false } },
                            { yAxis: -50, lineStyle: { color: 'rgba(249, 115, 22, 0.4)', width: 1, type: 'dashed' }, label: { show: false } },
                            { yAxis: -100, lineStyle: { color: 'rgba(220, 38, 38, 0.4)', width: 1, type: 'dashed' }, label: { show: false } }
                        ],
                        label: { show: false }
                    }
                }],
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    borderColor: '#444',
                    textStyle: { color: '#fff', fontSize: 11 },
                    formatter: function(params) {
                        return params[0].value.toFixed(0) + ' nT<br>' + params[0].axisValue + ' UTC';
                    }
                }
            };
            
            chart.setOption(option);
        }

        async function refreshDashboard() {
            loadingOverlay.classList.add('active');

            try {
                // 1. Fetch Data
                const dataResponse = await fetch('/api/aurora-data');
                const data = await dataResponse.json();
                
                // 2. Update UI
                updateDataCard(data);
                renderCharts(data);
                
                // 3. Check for alerts
                checkForAlerts(data);
                
                // 4. Update aurora probability if latitude is set
                if (document.getElementById('user-latitude').value) {
                    updateAuroraProbability();
                }

                // 5. Fetch Geomagnetic Alerts
                fetchGeomagneticAlerts();
                
                // 6. Fetch Solar Regions
                fetchSolarRegions();

                // 4. Refresh Map Image with robust error handling and retries
                refreshAuroraMap();
                
                // Force resize to fix layout bugs
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 100);

            } catch (error) {
                console.error('Error refreshing dashboard:', error);
                showToast('Failed to refresh data', 'error');
                loadingOverlay.classList.remove('active');
            }
        }
        
        // Robust map loading function with multiple retries and exponential backoff
        async function refreshAuroraMap(maxRetries = 3) {
            const timestamp = Date.now();
            let retryCount = 0;
            
            const finishMapLoad = (success = true) => {
                loadingOverlay.classList.remove('active');
                nextRefreshTime = Date.now() + 60000;
                if (success) {
                    console.log('Aurora map loaded successfully');
                }
            };
            
            const attemptLoad = (attemptNum) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    const src = `/aurora-map.png?t=${timestamp + attemptNum}`;
                    let timeoutId;
                    
                    const cleanup = () => {
                        clearTimeout(timeoutId);
                        img.onload = null;
                        img.onerror = null;
                    };
                    
                    img.onload = () => {
                        cleanup();
                        mapImage.src = src;
                        resolve(true);
                    };
                    
                    img.onerror = () => {
                        cleanup();
                        console.warn(`Map load attempt ${attemptNum + 1} failed`);
                        resolve(false);
                    };
                    
                    // Timeout after 15 seconds per attempt
                    timeoutId = setTimeout(() => {
                        cleanup();
                        console.warn(`Map load attempt ${attemptNum + 1} timed out`);
                        resolve(false);
                    }, 15000);
                    
                    img.src = src;
                });
            };
            
            // Try loading with exponential backoff
            for (let i = 0; i < maxRetries; i++) {
                const success = await attemptLoad(i);
                if (success) {
                    finishMapLoad(true);
                    return;
                }
                // Wait before retry: 1s, 2s, 4s
                if (i < maxRetries - 1) {
                    await new Promise(r => setTimeout(r, 1000 * Math.pow(2, i)));
                }
            }
            
            // All retries failed - still finish loading state
            console.error('Aurora map failed to load after all retries');
            finishMapLoad(false);
        }

        async function fetchGeomagneticAlerts() {
            try {
                console.log('[GEOMAG_ALERTS] Fetching geomagnetic forecast...');
                const response = await fetch('/api/geomagnetic-alerts?t=' + Date.now());
                const data = await response.json();
                
                console.log('[GEOMAG_ALERTS] Received forecast data:', data);
                
                const container = document.getElementById('geomag-forecast-container');
                if (!container) return;
                
                if (!data.forecast || data.forecast.length === 0) {
                    console.warn('[GEOMAG_ALERTS] No forecast data available');
                    container.innerHTML = '<p style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 1rem;">No forecast data available</p>';
                    return;
                }
                
                // Find the maximum Kp and G-scale values across all forecast periods
                // Store the max forecast Kp globally so updateDataCard can use it
                window.forecastMaxKp = Math.max(...data.forecast.map(f => f.max_kp));
                window.forecastMaxGScale = Math.max(...data.forecast.map(f => f.g_scale));
                
                console.log('[GEOMAG_ALERTS] Max forecast Kp: ' + window.forecastMaxKp + ', Max G-scale: ' + window.forecastMaxGScale);
                data.forecast.forEach((day, idx) => {
                    console.log('[GEOMAG_ALERTS] Day ' + idx + ' (' + day.date + '): Kp=' + day.max_kp + ', G=' + day.g_scale);
                });
                
                // Build the forecast chart
                let html = '<div class="forecast-grid">';
                
                data.forecast.forEach((day, index) => {
                    // Parse the date string in UTC to avoid timezone boundary issues
                    const date = new Date(day.date + 'T00:00:00Z');
                    
                    const dayName = index === 0 ? 'Today' : 
                                   index === 1 ? 'Tomorrow' : 
                                   date.toLocaleDateString('en-US', { weekday: 'short', timeZone: 'UTC' });
                    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'UTC' });
                    
                    const gScale = day.g_scale;
                    const gClass = `g${gScale}`;
                    const gLabel = gScale === 0 ? 'Quiet' : `G${gScale}`;
                    
                    html += `
                        <div class="forecast-day">
                            <div class="forecast-date">${dayName}</div>
                            <div class="forecast-date" style="font-size: 0.65rem; margin-top: -0.25rem;">${dateStr}</div>
                            <div class="forecast-bar-container">
                                <div class="forecast-bar">
                                    <div class="forecast-fill ${gClass}">
                                        ${gLabel}
                                    </div>
                                </div>
                                <div class="forecast-kp">Kp ${day.max_kp}</div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                // Add legend with separate colors for each G-level
                html += `
                    <div class="forecast-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ade80;"></div>
                            <span>G0</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #fbbf24;"></div>
                            <span>G1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #fb923c;"></div>
                            <span>G2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ef4444;"></div>
                            <span>G3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #dc2626;"></div>
                            <span>G4</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #991b1b;"></div>
                            <span>G5</span>
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Error fetching geomagnetic forecast:', error);
            }
        }

        async function fetchSolarRegions() {
            try {
                const response = await fetch('/api/solar-data');
                const data = await response.json();
                
                const tbody = document.getElementById('regions-body-overview');
                if (!tbody) return;
                
                if (!data.sunspots || data.sunspots.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 1rem; color: var(--text-secondary);">No active regions</td></tr>';
                    return;
                }
                
                tbody.innerHTML = '';
                
                // Show up to 5 most recent regions
                const regionsToShow = data.sunspots.slice(0, 5);
                
                regionsToShow.forEach(region => {
                    const tr = document.createElement('tr');
                    
                    // Determine mag type class
                    let magClass = '';
                    const magType = region.mag_type.toLowerCase();
                    if (magType.includes('beta-gamma-delta')) magClass = 'mag-bgd';
                    else if (magType.includes('gamma')) magClass = 'mag-gamma';
                    else if (magType.includes('beta')) magClass = 'mag-beta';
                    else magClass = 'mag-alpha';

                    // Determine flare badge
                    let flareBadge = '';
                    if (region.x_flares > 0) flareBadge = '<span class="region-flare-badge flare-x">X</span>';
                    else if (region.m_flares > 0) flareBadge = '<span class="region-flare-badge flare-m">M</span>';
                    else if (region.c_flares > 0) flareBadge = '<span class="region-flare-badge flare-c">C</span>';
                    
                    // Determine area size class
                    let areaClass = '';
                    const area = parseInt(region.area);
                    if (!isNaN(area)) {
                        if (area >= 1200) areaClass = 'area-huge';
                        else if (area >= 900) areaClass = 'area-large';
                        else if (area >= 650) areaClass = 'area-medium';
                        else if (area >= 300) areaClass = 'area-small';
                        else areaClass = 'area-tiny';
                    }
                    
                    // Compact mag type display
                    let shortMagType = region.mag_type;
                    if (magType.includes('beta-gamma-delta')) shortMagType = 'Î²Î³Î´';
                    else if (magType.includes('beta-gamma')) shortMagType = 'Î²Î³';
                    else if (magType.includes('beta')) shortMagType = 'Î²';
                    else if (magType.includes('alpha')) shortMagType = 'Î±';

                    tr.innerHTML = `
                        <td><span class="region-number">${region.number}</span>${flareBadge}</td>
                        <td style="color: var(--text-secondary);">${region.location}</td>
                        <td><span class="region-mag-type ${magClass}">${shortMagType}</span></td>
                        <td><span class="region-area ${areaClass}">${region.area}</span></td>
                    `;
                    tbody.appendChild(tr);
                });
                
                // Add link to full solar page if there are more regions
                if (data.sunspots.length > 5) {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td colspan="4" style="text-align: center; padding: 0.5rem;">
                            <a href="/solar" style="color: var(--accent-primary); text-decoration: none; font-size: 0.7rem;">
                                View all ${data.sunspots.length} regions â†’
                            </a>
                        </td>
                    `;
                    tbody.appendChild(tr);
                }
                
            } catch (error) {
                console.error('Error fetching solar regions:', error);
                const tbody = document.getElementById('regions-body-overview');
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 1rem; color: var(--text-secondary);">Error loading regions</td></tr>';
                }
            }
        }

        function renderCharts(data) {
            // Skip rendering during resize to prevent glitches
            if (isResizing) return;
            
            // Validate data exists before rendering
            if (!data || !data.solar_wind_history) {
                console.warn('Chart data not ready yet');
                return;
            }
            
            // Mobile-optimized margins and font sizes
            const mobileFontSize = isMobile ? 8 : 10;
            
            // Common ECharts grid settings
            const commonGrid = isMobile 
                ? { left: 30, right: 5, top: 5, bottom: 20, containLabel: false }
                : { left: 35, right: 8, top: 25, bottom: 25, containLabel: false };
            
            // Helper to initialize or get ECharts instance
            function getChartInstance(id) {
                const container = document.getElementById(id);
                if (!container) return null;
                
                if (window.echartsInstances[id]) {
                    window.echartsInstances[id].dispose();
                }
                const chart = echarts.init(container);
                window.echartsInstances[id] = chart;
                return chart;
            }
            
            // Common axis styles
            const commonXAxis = {
                type: 'category',
                axisLine: { show: false },
                axisTick: { show: false },
                axisLabel: { 
                    color: '#94a3b8', 
                    fontSize: mobileFontSize,
                    formatter: (val) => {
                        const d = new Date(val);
                        return d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0');
                    }
                },
                splitLine: { show: false }
            };
            
            const commonYAxis = {
                type: 'value',
                axisLine: { show: false },
                axisTick: { show: false },
                axisLabel: { color: '#94a3b8', fontSize: mobileFontSize },
                splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } }
            };

            // 1. Solar Wind Speed with Gradient Fill
            if (data.solar_wind_history && data.solar_wind_history.times && data.solar_wind_history.speeds) {
                const hist = data.solar_wind_history;
                
                // Validate data exists and has minimum length
                if (!hist.speeds || hist.speeds.length === 0 || !hist.times || hist.times.length === 0) {
                    console.warn('No speed data available');
                    return;
                }
                
                if (hist.speeds.length !== hist.times.length) {
                    console.warn('Speed and time data length mismatch');
                    return;
                }
                
                // Remove single-point spikes from speed data
                const cleanedSpeeds = hist.speeds.map((val, idx, arr) => {
                    if (val === null || val === undefined) return null;
                    if (idx === 0 || idx === arr.length - 1) return val;
                    const prev = arr[idx - 1];
                    const next = arr[idx + 1];
                    if (prev !== null && next !== null) {
                        const avgNeighbor = (prev + next) / 2;
                        const deviation = Math.abs(val - avgNeighbor);
                        if (deviation > 150) return avgNeighbor;
                    }
                    return val;
                });
                hist.speeds = cleanedSpeeds;
                
                const speeds = hist.speeds.filter(s => s !== null && !isNaN(s));
                if (speeds.length === 0) {
                    console.warn('No valid speed data after filtering');
                    return;
                }
                const maxSpeed = Math.max(...speeds, 400);
                const minSpeed = Math.min(...speeds, 200);
                const yMin = Math.max(0, minSpeed - 50);
                const yMax = maxSpeed + 100;
                
                // Calculate gradient stops based on actual value thresholds mapped to chart range
                // Speed thresholds: 350 (green), 450 (yellow-green), 600 (yellow), 750 (orange), 850 (red), 1000 (pink)
                function normalizeValue(val) {
                    return Math.max(0, Math.min(1, (val - yMin) / (yMax - yMin)));
                }
                
                const chart = getChartInstance('chart-speed');
                if (chart) {
                    chart.setOption({
                        backgroundColor: 'transparent',
                        grid: commonGrid,
                        xAxis: { ...commonXAxis, data: hist.times },
                        yAxis: { ...commonYAxis, min: yMin, max: yMax },
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: 'rgba(15, 23, 42, 0.9)',
                            borderColor: 'rgba(255,255,255,0.1)',
                            textStyle: { color: '#f8fafc' },
                            formatter: (params) => `${Math.round(params[0].value)} km/s`
                        },
                        series: [{
                            type: 'line',
                            data: hist.speeds,
                            smooth: 0.3,
                            symbol: 'none',
                            lineStyle: { color: '#f8fafc', width: 2.5 },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 1, 0, 0, [
                                    { offset: 0, color: 'rgba(74, 222, 128, 0.6)' },
                                    { offset: normalizeValue(350), color: 'rgba(74, 222, 128, 0.6)' },
                                    { offset: normalizeValue(450), color: 'rgba(217, 249, 157, 0.6)' },
                                    { offset: normalizeValue(600), color: 'rgba(250, 204, 21, 0.6)' },
                                    { offset: normalizeValue(750), color: 'rgba(251, 146, 60, 0.6)' },
                                    { offset: normalizeValue(850), color: 'rgba(239, 68, 68, 0.6)' },
                                    { offset: normalizeValue(1000), color: 'rgba(236, 72, 153, 0.6)' },
                                    { offset: 1, color: 'rgba(255, 255, 255, 0.6)' }
                                ])
                            }
                        }]
                    });
                }
                
                const lastVal = hist.speeds[hist.speeds.length - 1];
                const valElem = document.getElementById('chart-val-speed');
                if (lastVal) {
                    valElem.textContent = Math.round(lastVal) + ' km/s';
                    if (lastVal >= 1000) valElem.style.color = '#ffffff';
                    else if (lastVal >= 850) valElem.style.color = '#ec4899';
                    else if (lastVal >= 750) valElem.style.color = '#ef4444';
                    else if (lastVal >= 600) valElem.style.color = '#fb923c';
                    else if (lastVal >= 450) valElem.style.color = '#facc15';
                    else if (lastVal >= 350) valElem.style.color = '#d9f99d';
                    else valElem.style.color = '#4ade80';
                }
            }

            // 2. Density with Gradient
            if (data.solar_wind_history && data.solar_wind_history.densities) {
                const hist = data.solar_wind_history;
                const densities = hist.densities.filter(d => d !== null && !isNaN(d));
                if (densities.length === 0) {
                    console.warn('No valid density data');
                } else {
                    const maxDensity = Math.max(...densities, 1);
                    const minDensity = Math.min(...densities, 0);
                    const range = Math.max(maxDensity - minDensity, 1);
                    const yMin = Math.max(0, minDensity - range * 0.3);
                    const yMax = maxDensity + range * 2;
                    
                    // Calculate gradient stops based on density thresholds mapped to y-axis range
                    const thresholds = [
                        { value: 2, color: 'rgba(187, 247, 208, 0.6)' },    // Very low (light green)
                        { value: 5, color: 'rgba(134, 239, 160, 0.6)' },    // Low (green)
                        { value: 10, color: 'rgba(22, 163, 74, 0.6)' },     // Normal (darker green)
                        { value: 20, color: 'rgba(250, 204, 21, 0.6)' },    // Elevated (yellow)
                        { value: 30, color: 'rgba(239, 68, 68, 0.6)' },     // High (red)
                        { value: 50, color: 'rgba(147, 51, 234, 0.6)' }     // Very high (purple)
                    ];
                    
                    const gradientStops = thresholds.map(t => {
                        const normalizedPos = (t.value - yMin) / (yMax - yMin);
                        return { offset: Math.max(0, Math.min(1, normalizedPos)), color: t.color };
                    }).sort((a, b) => a.offset - b.offset);
                    
                    const chart = getChartInstance('chart-density');
                    if (chart) {
                        chart.setOption({
                            backgroundColor: 'transparent',
                            grid: commonGrid,
                            xAxis: { ...commonXAxis, data: hist.times },
                            yAxis: { ...commonYAxis, min: yMin, max: yMax },
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(15, 23, 42, 0.9)',
                                borderColor: 'rgba(255,255,255,0.1)',
                                textStyle: { color: '#f8fafc' },
                                formatter: (params) => params[0].value?.toFixed(1) || '--'
                            },
                            series: [{
                                type: 'line',
                                data: hist.densities,
                                smooth: 0.3,
                                symbol: 'none',
                                lineStyle: { color: '#f8fafc', width: 2.5 },
                                areaStyle: {
                                    color: new echarts.graphic.LinearGradient(0, 1, 0, 0, gradientStops)
                                }
                            }]
                        });
                    }
                    
                    const lastVal = hist.densities[hist.densities.length - 1];
                    document.getElementById('chart-val-density').textContent = lastVal ? lastVal.toFixed(1) : '--';
                }
            }

            // 3. Bt with Gradient
            if (data.solar_wind_history && data.solar_wind_history.bts) {
                const hist = data.solar_wind_history;
                const bts = hist.bts.filter(b => b !== null && !isNaN(b));
                if (bts.length === 0) {
                    console.warn('No valid Bt data');
                } else {
                    const maxBt = Math.max(...bts, 10);
                    const minBt = Math.min(...bts, 0);
                    const yMin = Math.max(0, minBt - 2);
                    const yMax = maxBt + 3;
                    
                    // Calculate gradient stops based on Bt thresholds mapped to chart range
                    // Bt thresholds: 5 (quiet), 10 (moderate), 15 (active), 20 (storm), 30+ (severe)
                    function normalizeBt(val) {
                        return Math.max(0, Math.min(1, (val - yMin) / (yMax - yMin)));
                    }
                    
                    const chart = getChartInstance('chart-bt');
                    if (chart) {
                        chart.setOption({
                            backgroundColor: 'transparent',
                            grid: commonGrid,
                            xAxis: { ...commonXAxis, data: hist.times },
                            yAxis: { ...commonYAxis, min: yMin, max: yMax },
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(15, 23, 42, 0.9)',
                                borderColor: 'rgba(255,255,255,0.1)',
                                textStyle: { color: '#f8fafc' },
                                formatter: (params) => (params[0].value?.toFixed(1) || '--') + ' nT'
                            },
                            series: [{
                                type: 'line',
                                data: hist.bts,
                                smooth: 0.3,
                                symbol: 'none',
                                lineStyle: { color: '#f8fafc', width: 2.5 },
                                areaStyle: {
                                    color: new echarts.graphic.LinearGradient(0, 1, 0, 0, [
                                        { offset: 0, color: 'rgba(74, 222, 128, 0.5)' },
                                        { offset: normalizeBt(5), color: 'rgba(74, 222, 128, 0.5)' },
                                        { offset: normalizeBt(10), color: 'rgba(217, 249, 157, 0.5)' },
                                        { offset: normalizeBt(15), color: 'rgba(250, 204, 21, 0.5)' },
                                        { offset: normalizeBt(20), color: 'rgba(251, 146, 60, 0.5)' },
                                        { offset: normalizeBt(30), color: 'rgba(239, 68, 68, 0.5)' },
                                        { offset: 1, color: 'rgba(147, 51, 234, 0.5)' }
                                    ])
                                }
                            }]
                        });
                    }
                    
                    const lastVal = hist.bts[hist.bts.length - 1];
                    document.getElementById('chart-val-bt').textContent = lastVal ? lastVal.toFixed(1) + ' nT' : '--';
                }
            }

            // 4. Bz - Bipolar fill (green for positive, red for negative)
            if (data.solar_wind_history && data.solar_wind_history.bzs) {
                const hist = data.solar_wind_history;
                const bzs = hist.bzs.filter(b => b !== null && !isNaN(b));
                if (bzs.length === 0) {
                    console.warn('No valid Bz data');
                } else {
                    const maxBz = Math.max(...bzs, 5);
                    const minBz = Math.min(...bzs, -5);
                    const yMin = minBz - 2;
                    const yMax = maxBz + 2;
                    
                    // Create separate data arrays for positive and negative values
                    const positiveData = hist.bzs.map(v => (v !== null && v >= 0) ? v : 0);
                    const negativeData = hist.bzs.map(v => (v !== null && v < 0) ? v : 0);
                    
                    const chart = getChartInstance('chart-bz');
                    if (chart) {
                        chart.setOption({
                            backgroundColor: 'transparent',
                            grid: { left: 35, right: 10, top: 10, bottom: 25, containLabel: false },
                            xAxis: { ...commonXAxis, data: hist.times },
                            yAxis: { ...commonYAxis, min: yMin, max: yMax },
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(15, 23, 42, 0.9)',
                                borderColor: 'rgba(255,255,255,0.1)',
                                textStyle: { color: '#f8fafc' },
                                formatter: function(params) {
                                    // Show the actual Bz value (non-zero from either series)
                                    const val = params[0].value !== 0 ? params[0].value : params[1]?.value || 0;
                                    return (val?.toFixed(1) || '--') + ' nT';
                                }
                            },
                            series: [
                                {
                                    name: 'Bz Positive',
                                    type: 'line',
                                    data: positiveData,
                                    smooth: 0.3,
                                    symbol: 'none',
                                    lineStyle: { width: 0 },
                                    areaStyle: { 
                                        color: 'rgba(74, 222, 128, 0.5)',
                                        origin: 0
                                    },
                                    stack: 'bz'
                                },
                                {
                                    name: 'Bz Negative',
                                    type: 'line',
                                    data: negativeData,
                                    smooth: 0.3,
                                    symbol: 'none',
                                    lineStyle: { width: 0 },
                                    areaStyle: { 
                                        color: 'rgba(248, 113, 113, 0.5)',
                                        origin: 0
                                    },
                                    stack: 'bz'
                                },
                                {
                                    name: 'Bz Line',
                                    type: 'line',
                                    data: hist.bzs,
                                    smooth: 0.3,
                                    symbol: 'none',
                                    lineStyle: { color: '#f8fafc', width: 2.5 },
                                    markLine: {
                                        silent: true,
                                        symbol: 'none',
                                        lineStyle: { color: 'rgba(255,255,255,0.3)', width: 1, type: 'solid' },
                                        data: [{ yAxis: 0 }],
                                        label: { show: false }
                                    }
                                }
                            ],
                            legend: { show: false }
                        });
                    }
                    
                    const lastVal = hist.bzs[hist.bzs.length - 1];
                    const valElem = document.getElementById('chart-val-bz');
                    if (lastVal !== null) {
                        valElem.textContent = lastVal.toFixed(1) + ' nT';
                        valElem.style.color = lastVal < 0 ? '#ff4444' : '#4ade80';
                    }
                }
            }

            // 5. Magnetometer
            if (data.goes_magnetometer) {
                const mag = data.goes_magnetometer;
                
                // Validate that we have actual data
                const has18 = mag.goes18_hp && mag.goes18_hp.length > 0 && mag.goes18_times && mag.goes18_times.length > 0;
                const has19 = mag.goes19_hp && mag.goes19_hp.length > 0 && mag.goes19_times && mag.goes19_times.length > 0;
                
                if (!has18 && !has19) {
                    console.warn('No magnetometer data available');
                } else {
                    // Use the times from whichever dataset we have
                    const times = has18 ? mag.goes18_times : mag.goes19_times;
                    
                    const series = [];
                    if (has18) {
                        series.push({
                            name: 'GOES-18',
                            type: 'line',
                            data: mag.goes18_hp,
                            symbol: 'none',
                            smooth: 0.3,
                            lineStyle: { color: '#60a5fa', width: 2 }
                        });
                    }
                    if (has19) {
                        series.push({
                            name: 'GOES-19',
                            type: 'line',
                            data: mag.goes19_hp,
                            symbol: 'none',
                            smooth: 0.3,
                            lineStyle: { color: '#f87171', width: 2 }
                        });
                    }
                    
                    const chart = getChartInstance('chart-mag');
                    if (chart) {
                        chart.setOption({
                            backgroundColor: 'transparent',
                            grid: commonGrid,
                            legend: {
                                show: true,
                                left: 0,
                                top: 0,
                                textStyle: { color: '#94a3b8', fontSize: 9 },
                                itemWidth: 15,
                                itemHeight: 10
                            },
                            xAxis: { ...commonXAxis, data: times },
                            yAxis: { ...commonYAxis, name: 'nT', nameLocation: 'middle', nameGap: 25 },
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(15, 23, 42, 0.9)',
                                borderColor: 'rgba(255,255,255,0.1)',
                                textStyle: { color: '#f8fafc' },
                                formatter: function(params) {
                                    let result = '';
                                    params.forEach(p => {
                                        result += p.seriesName + ': ' + (p.value?.toFixed(1) || '--') + ' nT<br>';
                                    });
                                    return result;
                                }
                            },
                            series: series
                        });
                    }
                }
                
                // Substorm detection logic
                let substormActive = false;
                const thresholdChange = 40;
                
                if (mag.goes18_hp && mag.goes18_hp.length >= 20) {
                    const recentHp = mag.goes18_hp.slice(-20);
                    const hpMax = Math.max(...recentHp.filter(v => v !== null));
                    const hpMin = Math.min(...recentHp.filter(v => v !== null));
                    const hpChange = hpMax - hpMin;
                    if (hpChange >= thresholdChange) {
                        const maxIdx = recentHp.indexOf(hpMax);
                        if (maxIdx >= 5) {
                            const currentHp = recentHp[recentHp.length - 1];
                            if (currentHp >= hpMin + (thresholdChange * 0.5)) substormActive = true;
                        }
                    }
                }
                
                if (mag.goes19_hp && mag.goes19_hp.length >= 20) {
                    const recentHp = mag.goes19_hp.slice(-20);
                    const hpMax = Math.max(...recentHp.filter(v => v !== null));
                    const hpMin = Math.min(...recentHp.filter(v => v !== null));
                    const hpChange = hpMax - hpMin;
                    if (hpChange >= thresholdChange) {
                        const maxIdx = recentHp.indexOf(hpMax);
                        if (maxIdx >= 5) {
                            const currentHp = recentHp[recentHp.length - 1];
                            if (currentHp >= hpMin + (thresholdChange * 0.5)) substormActive = true;
                        }
                    }
                }
                
                const badge = document.getElementById('substorm-badge');
                if (badge) {
                    if (substormActive) {
                        badge.textContent = 'SUBSTORM: ACTIVE';
                        badge.style.borderColor = '#ef4444';
                        badge.style.color = '#ef4444';
                    } else {
                        badge.textContent = 'SUBSTORM: INACTIVE';
                        badge.style.borderColor = '#10b981';
                        badge.style.color = '#10b981';
                    }
                }
            }

            // 6. Hemispheric Power
            if (data.hemispheric_power) {
                const power = data.hemispheric_power;
                
                // Validate data exists
                if (!power.times || !power.powers || power.times.length === 0 || power.powers.length === 0) {
                    console.warn('No hemispheric power data available');
                } else {
                    const count = 20;
                    const times = power.times.slice(-count);
                    const values = power.powers.slice(-count);
                    
                    const barData = values.map(v => ({
                        value: v,
                        itemStyle: {
                            color: v < 30 ? '#6b7280' : v < 50 ? '#22c55e' : v < 100 ? '#f59e0b' : '#ef4444'
                        }
                    }));
                    
                    const chart = getChartInstance('chart-power');
                    if (chart) {
                        chart.setOption({
                            backgroundColor: 'transparent',
                            grid: commonGrid,
                            xAxis: { ...commonXAxis, data: times },
                            yAxis: { ...commonYAxis, min: 0 },
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(15, 23, 42, 0.9)',
                                borderColor: 'rgba(255,255,255,0.1)',
                                textStyle: { color: '#f8fafc' },
                                formatter: (params) => Math.round(params[0].value) + ' GW'
                            },
                            series: [{
                                type: 'bar',
                                data: barData,
                                barWidth: '60%'
                            }]
                        });
                    }
                    
                    const lastVal = values[values.length - 1];
                    document.getElementById('chart-val-power').textContent = lastVal ? Math.round(lastVal) + ' GW' : '--';
                }
            }
            
            // Force ECharts to resize all charts after render
            setTimeout(() => {
                resizeAllCharts();
            }, 100);
        }
        
        // Global resize function for all ECharts instances
        function resizeAllCharts() {
            // Skip if we're in the middle of a resize animation
            if (isResizing) return;
            
            // Use requestAnimationFrame for smoother resizing
            requestAnimationFrame(() => {
                Object.keys(window.echartsInstances).forEach(id => {
                    const chart = window.echartsInstances[id];
                    if (chart && !chart.isDisposed()) {
                        try {
                            chart.resize();
                        } catch (e) {
                            console.warn(`Failed to resize chart ${id}:`, e);
                        }
                    }
                });
            });
        }

        function formatKp(kp) {
            // Convert decimal Kp to proper format
            if (kp === null || kp === undefined || kp === '--') return 'N/A';
            
            const kpNum = typeof kp === 'string' ? parseFloat(kp) : kp;
            if (isNaN(kpNum)) return kp;
            
            // Return decimal value rounded to 1 decimal place
            return kpNum.toFixed(1);
        }
        
        function updateDataCard(data) {
            const safeVal = (val, decimals = 1) => val !== null && val !== undefined ? Number(val).toFixed(decimals) : '--';
            
            // Get observed Kp - but check if it's stale and use G-scale estimate if needed
            let kp = data.kp_index?.kp || 0;
            const kpTime = data.kp_index?.time || '';
            const noaaGScale = parseInt(data.noaa_scales?.g_scale) || 0;
            
            // NOAA Kp is updated every 3 hours. If live G-scale differs significantly
            // from what the Kp suggests, show an estimated Kp based on G-scale
            // G-scale to Kp midpoint: G0=2, G1=5, G2=6, G3=7, G4=8, G5=9
            const gToKpEstimate = [2, 5, 6, 7, 8, 9];
            const kpFromG = gToKpEstimate[noaaGScale] || 0;
            
            // If the observed Kp implies a different G-scale than current, use estimate
            let calculatedG = 0;
            if (kp > 8.67) calculatedG = 5;
            else if (kp >= 7.67) calculatedG = 4;
            else if (kp >= 6.67) calculatedG = 3;
            else if (kp >= 5.67) calculatedG = 2;
            else if (kp >= 5.00) calculatedG = 1;
            
            if (Math.abs(calculatedG - noaaGScale) >= 1 && noaaGScale >= 0) {
                // Kp is stale - use estimate from live G-scale
                kp = kpFromG;
                console.log('[KP_INDEX] Kp data stale, estimated Kp ' + kp + ' from live G' + noaaGScale);
            } else {
                console.log('[KP_INDEX] Observed Kp: ' + kp + ' at ' + kpTime);
            }
            
            document.getElementById('kp-value-text').textContent = formatKp(kp);
            const kpFill = document.getElementById('kp-fill');
            const kpPercent = Math.min((kp / 9) * 100, 100);
            kpFill.style.width = `${kpPercent}%`;
            
            // Apply Kp color scale
            if (kp >= 9) kpFill.style.background = '#ec4899';      // Kp9 (G5): Pink
            else if (kp >= 8) kpFill.style.background = '#a855f7'; // Kp8 (G4): Purple
            else if (kp >= 7) kpFill.style.background = '#ef4444'; // Kp7 (G3): Red
            else if (kp >= 6) kpFill.style.background = '#fb923c'; // Kp6 (G2): Orange
            else if (kp >= 5) kpFill.style.background = '#fbbf24'; // Kp5 (G1): Yellow
            else if (kp >= 4) kpFill.style.background = '#84cc16'; // Kp4: Light Green
            else if (kp >= 3) kpFill.style.background = '#166534'; // Kp3: Dark Green
            else kpFill.style.background = '#6b7280';              // Kp0-2: Gray
            
            // G-Scale: Use the live NOAA scale value we already have
            // noaaGScale was already parsed above for Kp staleness detection
            let gScale = noaaGScale;
            console.log('[G_SCALE] Using live NOAA G-scale: G' + gScale);
            
            const gElem = document.getElementById('g-scale-display');
            gElem.innerHTML = `G${gScale} <span style="font-size: 0.8rem; font-weight: 400; opacity: 0.7;">STORM SCALE</span>`;
            
            if (gScale >= 4) {
                gElem.style.color = 'var(--danger)';
                gElem.style.opacity = '1';
                gElem.style.textShadow = '0 0 20px rgba(248, 113, 113, 0.5)';
            } else if (gScale >= 1) {
                gElem.style.color = 'var(--warning)';
                gElem.style.opacity = '1';
                gElem.style.textShadow = '0 0 15px rgba(251, 191, 36, 0.3)';
            } else {
                gElem.style.color = 'var(--text-secondary)';
                gElem.style.opacity = '0.5';
                gElem.style.textShadow = 'none';
            }




        }

        async function downloadDashboard() {
            try {
                const canvas = await createDashboardCanvas();
                const link = document.createElement('a');
                link.download = `aurora_dashboard_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                showToast('Dashboard downloaded', 'success');
            } catch (err) {
                console.error(err);
                showToast('Failed to download dashboard', 'error');
            }
        }

        async function copyImageToClipboard() {
            try {
                const canvas = await createDashboardCanvas();
                canvas.toBlob(async (blob) => {
                    await navigator.clipboard.write([
                        new ClipboardItem({ 'image/png': blob })
                    ]);
                    showToast('Dashboard copied to clipboard', 'success');
                });
            } catch (err) {
                console.error(err);
                showToast('Failed to copy image', 'error');
            }
        }

        async function createDashboardCanvas() {
            // Create a canvas to compose all elements
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size matching reference layout (landscape, ~16:10 aspect)
            const width = 2400;
            const height = 1500;
            canvas.width = width;
            canvas.height = height;
            
            // Fill background
            ctx.fillStyle = '#0b1121';
            ctx.fillRect(0, 0, width, height);
            
            // Layout dimensions
            const mapWidth = 1100;
            const mapHeight = 1200;
            const chartWidth = 1300;
            const chartHeight = 300;
            const bottomHeight = 280;
            
            // Get aurora map (left side, top portion)
            const mapImg = await loadImage(mapImage.src);
            ctx.drawImage(mapImg, 0, 0, mapWidth, mapHeight);
            
            // Draw Kp Index panel at top right (recreate the visual)
            const kpPanelX = mapWidth;
            const kpPanelY = 0;
            const kpPanelHeight = 120;
            
            // Kp panel background
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(kpPanelX + 20, kpPanelY + 20, chartWidth - 40, kpPanelHeight);
            
            // Kp title
            ctx.fillStyle = '#94a3b8';
            ctx.font = 'bold 20px Outfit, Inter, sans-serif';
            ctx.fillText('PLANETARY K-INDEX', kpPanelX + 40, kpPanelY + 50);
            
            // Kp value
            const kpValue = document.getElementById('kp-value-text').textContent;
            ctx.fillStyle = '#f8fafc';
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(kpValue, kpPanelX + chartWidth - 40, kpPanelY + 55);
            ctx.textAlign = 'left';
            
            // G-Scale display
            const gScaleText = document.getElementById('g-scale-display').textContent;
            ctx.fillStyle = '#94a3b8';
            ctx.font = 'bold 18px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(gScaleText, kpPanelX + chartWidth / 2, kpPanelY + 85);
            ctx.textAlign = 'left';
            
            // Kp meter bar
            const kpFill = document.getElementById('kp-fill');
            const kpPercent = parseFloat(kpFill.style.width) || 0;
            const barX = kpPanelX + 40;
            const barY = kpPanelY + 95;
            const barWidth = chartWidth - 80;
            const barHeight = 10;
            
            // Background bar
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            // Filled bar
            const fillWidth = (barWidth * kpPercent) / 100;
            const fillColor = kpFill.style.background || '#4ade80';
            ctx.fillStyle = fillColor;
            ctx.fillRect(barX, barY, fillWidth, barHeight);
            
            // Right side: 4 stacked charts (Speed, Density, Bt, Bz) - shifted down for Kp panel
            const chartStartY = kpPanelHeight + 20;
            const adjustedChartHeight = (1200 - chartStartY) / 4;
            
            const rightCharts = [
                { id: 'chart-speed', x: mapWidth, y: chartStartY, height: adjustedChartHeight },
                { id: 'chart-density', x: mapWidth, y: chartStartY + adjustedChartHeight, height: adjustedChartHeight },
                { id: 'chart-bt', x: mapWidth, y: chartStartY + adjustedChartHeight * 2, height: adjustedChartHeight },
                { id: 'chart-bz', x: mapWidth, y: chartStartY + adjustedChartHeight * 3, height: adjustedChartHeight }
            ];
            
            // Bottom row: Magnetometer (left) and Hemispheric Power (right)
            const bottomCharts = [
                { id: 'chart-mag', x: 0, y: mapHeight, height: bottomHeight, width: mapWidth },
                { id: 'chart-power', x: mapWidth, y: mapHeight, height: bottomHeight, width: chartWidth }
            ];
            
            // Capture right side charts - using ECharts getDataURL
            for (const chart of rightCharts) {
                try {
                    const chartInstance = window.echartsInstances[chart.id];
                    if (chartInstance && !chartInstance.isDisposed()) {
                        const imgData = chartInstance.getDataURL({
                            type: 'png',
                            pixelRatio: 2,
                            backgroundColor: 'transparent'
                        });
                        const img = await loadImage(imgData);
                        ctx.drawImage(img, chart.x, chart.y, chartWidth, chart.height);
                    }
                } catch (e) {
                    console.warn(`Failed to capture ${chart.id}:`, e);
                }
            }
            
            // Capture bottom row charts - using ECharts getDataURL
            for (const chart of bottomCharts) {
                try {
                    const chartInstance = window.echartsInstances[chart.id];
                    if (chartInstance && !chartInstance.isDisposed()) {
                        const imgData = chartInstance.getDataURL({
                            type: 'png',
                            pixelRatio: 2,
                            backgroundColor: 'transparent'
                        });
                        const img = await loadImage(imgData);
                        ctx.drawImage(img, chart.x, chart.y, chart.width, chart.height);
                    }
                } catch (e) {
                    console.warn(`Failed to capture ${chart.id}:`, e);
                }
            }
            
            // Add labels and values overlay
            ctx.font = 'bold 24px sans-serif';
            ctx.fillStyle = '#94a3b8';
            
            // Get Bz value and determine color/direction
            const bzValue = document.getElementById('chart-val-bz').textContent;
            const bzNumeric = parseFloat(bzValue);
            const bzDirection = bzNumeric >= 0 ? 'NORTH' : 'SOUTH';
            const bzColor = bzNumeric >= 0 ? '#4ade80' : '#ef4444';
            const bzDisplay = `${bzValue} ${bzDirection}`;
            
            // Chart labels and values for right side (using already defined chartStartY and adjustedChartHeight)
            const labels = [
                { text: 'SOLAR WIND SPEED', value: document.getElementById('chart-val-speed').textContent, x: mapWidth + 30, y: chartStartY + 30, color: '#f8fafc' },
                { text: 'PROTON DENSITY', value: document.getElementById('chart-val-density').textContent, x: mapWidth + 30, y: chartStartY + adjustedChartHeight + 30, color: '#f8fafc' },
                { text: 'IMF BT', value: document.getElementById('chart-val-bt').textContent, x: mapWidth + 30, y: chartStartY + adjustedChartHeight * 2 + 30, color: '#f8fafc' },
                { text: 'IMF BZ', value: bzDisplay, x: mapWidth + 30, y: chartStartY + adjustedChartHeight * 3 + 30, color: bzColor }
            ];
            
            labels.forEach(label => {
                // Draw label with Outfit font
                ctx.fillStyle = '#94a3b8';
                ctx.font = 'bold 20px Outfit, Inter, sans-serif';
                ctx.fillText(label.text, label.x, label.y);
                
                // Draw value (right aligned)
                ctx.fillStyle = label.color;
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(label.value, mapWidth + chartWidth - 30, label.y + 5);
                ctx.textAlign = 'left';
            });
            
            // Bottom row labels with Outfit font
            ctx.fillStyle = '#94a3b8';
            ctx.font = 'bold 20px Outfit, Inter, sans-serif';
            ctx.fillText('GOES MAGNETOMETER', 30, mapHeight + 30);
            ctx.fillText('HEMISPHERIC POWER', mapWidth + 30, mapHeight + 30);
            
            // Hemispheric power value
            const powerVal = document.getElementById('chart-val-power').textContent;
            ctx.fillStyle = '#f8fafc';
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(powerVal, width - 30, mapHeight + 35);
            ctx.textAlign = 'left';
            
            // Add logo (top left corner, small)
            try {
                const logo = await loadImage('/wtusredlogotransparentx.png');
                const logoHeight = 60; // Small size
                const logoWidth = (logo.width / logo.height) * logoHeight;
                ctx.globalAlpha = 0.8; // Slightly transparent
                ctx.drawImage(logo, 20, 20, logoWidth, logoHeight);
                ctx.globalAlpha = 1.0; // Reset opacity
            } catch (e) {
                console.warn('Failed to load logo:', e);
            }
            
            return canvas;
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        async function generateGif() {
            const btn = document.getElementById('generate-gif-btn');
            const progressBar = document.getElementById('gif-progress');
            const progressFill = document.getElementById('gif-progress-bar');
            const statusText = document.getElementById('gif-status-text');
            
            const hours = document.getElementById('gif-hours').value;
            const interval = document.getElementById('gif-interval').value;

            btn.disabled = true;
            btn.textContent = 'Generating...';
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
            statusText.textContent = 'Generating animation from historical data...';

            let progress = 0;
            const progressAnim = setInterval(() => {
                if (progress < 90) {
                    progress += 2;
                    progressFill.style.width = `${progress}%`;
                }
            }, 100);

            try {
                const response = await fetch(`/generate-gif?hours=${hours}&interval=${interval}&duration=500&mode=historical`);
                
                if (!response.ok) throw new Error('Generation failed');

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `aurora_historical_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.gif`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                clearInterval(progressAnim);
                progressFill.style.width = '100%';
                statusText.textContent = 'Download started! Generated instantly from historical data.';
                showToast('GIF generated successfully', 'success');

            } catch (error) {
                console.error(error);
                showToast('Failed to generate GIF', 'error');
                statusText.textContent = 'Error generating GIF';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Generate Animation';
                setTimeout(() => {
                    progressBar.style.display = 'none';
                    statusText.textContent = '';
                }, 5000);
            }
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const icon = document.getElementById('toast-icon');
            const msg = document.getElementById('toast-message');
            // No emoji icons: leave icon text empty
            icon.textContent = '';
            msg.textContent = message;
            
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Aurora Probability Calculator
        async function updateAuroraProbability() {
            const latitude = document.getElementById('user-latitude').value;
            if (!latitude || latitude === '') {
                document.getElementById('prob-percentage').textContent = '--%';
                document.getElementById('prob-visibility').textContent = 'Enter your latitude';
                return;
            }

            try {
                const response = await fetch(`/api/aurora-probability?lat=${latitude}`);
                const data = await response.json();
                
                document.getElementById('prob-percentage').textContent = `${data.probability}%`;
                document.getElementById('prob-visibility').textContent = data.visibility;
                document.getElementById('prob-percentage').style.color = data.color;
                
                // Save to localStorage
                localStorage.setItem('userLatitude', latitude);
            } catch (error) {
                console.error('Error fetching aurora probability:', error);
            }
        }

        // Timezone functions
        let currentTimezone = 'UTC';

        function updateTimezone() {
            currentTimezone = document.getElementById('timezone-selector').value;
            localStorage.setItem('timezone', currentTimezone);
            
            // Update the UTC clock display immediately
            updateUtcTime();
        }

        function updateUtcTime() {
            const now = new Date();
            const timeElem = document.getElementById('utc-time');
            
            if (currentTimezone === 'UTC') {
                const hours = String(now.getUTCHours()).padStart(2, '0');
                const minutes = String(now.getUTCMinutes()).padStart(2, '0');
                timeElem.textContent = `${hours}:${minutes} UTC`;
            } else if (currentTimezone === 'local') {
                const hours = now.getHours();
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const hour12 = hours % 12 || 12;
                const ampm = hours >= 12 ? 'PM' : 'AM';
                
                // Get timezone abbreviation
                const tzString = now.toLocaleTimeString('en-US', { timeZoneName: 'short' });
                const tzAbbr = tzString.split(' ').pop();
                
                timeElem.textContent = `${hour12}:${minutes} ${ampm} ${tzAbbr}`;
            } else {
                try {
                    const tzDate = new Date(now.toLocaleString('en-US', { timeZone: currentTimezone }));
                    const hours = tzDate.getHours();
                    const minutes = String(tzDate.getMinutes()).padStart(2, '0');
                    const hour12 = hours % 12 || 12;
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    
                    // Get timezone abbreviation with DST support
                    const tzString = now.toLocaleTimeString('en-US', { 
                        timeZone: currentTimezone, 
                        timeZoneName: 'short' 
                    });
                    const tzAbbr = tzString.split(' ').pop();
                    
                    timeElem.textContent = `${hour12}:${minutes} ${ampm} ${tzAbbr}`;
                } catch (e) {
                    const hours = String(now.getUTCHours()).padStart(2, '0');
                    const minutes = String(now.getUTCMinutes()).padStart(2, '0');
                    timeElem.textContent = `${hours}:${minutes} UTC`;
                }
            }
        }

        function formatTimeInTimezone(isoString) {
            const date = new Date(isoString);
            
            if (currentTimezone === 'UTC') {
                return date.toISOString().slice(11, 16) + ' UTC';
            } else if (currentTimezone === 'local') {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else {
                try {
                    return date.toLocaleString('en-US', { 
                        timeZone: currentTimezone, 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                } catch (e) {
                    return date.toISOString().slice(11, 16) + ' UTC';
                }
            }
        }

        // Moon Phase Calculator
        function calculateMoonPhase() {
            const now = new Date();
            
            // Known new moon: January 29, 2025 at 12:36 UTC (more recent reference)
            const knownNewMoon = new Date('2025-01-29T12:36:00Z');
            const lunarCycle = 29.53058867; // days
            
            // Calculate days since known new moon
            const daysSinceNew = (now - knownNewMoon) / (1000 * 60 * 60 * 24);
            const daysInCycle = ((daysSinceNew % lunarCycle) + lunarCycle) % lunarCycle;
            const phase = daysInCycle / lunarCycle;
            
            // Calculate illumination percentage (more accurate formula)
            // Illumination increases from 0 at new moon to 100% at full moon (phase 0.5)
            const illuminationPercent = Math.round(50 * (1 - Math.cos(phase * 2 * Math.PI)));
            
            // Determine phase name and visibility impact
            let phaseName, visibilityImpact;
            
            if (phase < 0.033 || phase > 0.967) {
                phaseName = 'New Moon';
                visibilityImpact = 'Excellent for aurora viewing - dark skies';
            } else if (phase < 0.216) {
                phaseName = 'Waxing Crescent';
                visibilityImpact = 'Very good - minimal moonlight interference';
            } else if (phase < 0.283) {
                phaseName = 'First Quarter';
                visibilityImpact = 'Good - moon sets around midnight';
            } else if (phase < 0.466) {
                phaseName = 'Waxing Gibbous';
                visibilityImpact = 'Fair - bright moon may reduce visibility';
            } else if (phase < 0.533) {
                phaseName = 'Full Moon';
                visibilityImpact = 'Poor - bright moonlight washes out aurora';
            } else if (phase < 0.716) {
                phaseName = 'Waning Gibbous';
                visibilityImpact = 'Fair - moon rises late';
            } else if (phase < 0.783) {
                phaseName = 'Last Quarter';
                visibilityImpact = 'Good - moon rises after midnight';
            } else {
                phaseName = 'Waning Crescent';
                visibilityImpact = 'Very good - moon rises near dawn';
            }
            
            // Generate realistic moon SVG based on phase
            const moonImgElem = document.getElementById('moon-image');
            if (moonImgElem) {
                moonImgElem.src = generateMoonSVG(phase);
                moonImgElem.alt = phaseName;
            }
            document.getElementById('moon-phase-name').textContent = phaseName;
            document.getElementById('moon-illumination').textContent = `${illuminationPercent}% illuminated`;
            document.getElementById('moon-visibility-impact').textContent = visibilityImpact;
        }
        
        // Generate a realistic moon SVG based on phase (0-1)
        function generateMoonSVG(phase) {
            const size = 100;
            const cx = size / 2;
            const cy = size / 2;
            const r = 42;
            
            // Waxing (0-0.5) = right side lit, Waning (0.5-1) = left side lit
            const isWaxing = phase < 0.5;
            const adjustedPhase = isWaxing ? phase : phase - 0.5;
            
            // Calculate terminator curve
            // At phase 0 (new) and 0.5 (full relative): terminator at edge
            // Phase 0.25: half moon (terminator at center)
            const terminatorX = r * Math.cos(adjustedPhase * 2 * Math.PI);
            
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${size} ${size}">`;
            
            // Add subtle outer glow
            svg += `<defs>
                <radialGradient id="moonGlow" cx="50%" cy="50%" r="50%">
                    <stop offset="85%" stop-color="%23e8e4d9" stop-opacity="1"/>
                    <stop offset="100%" stop-color="%23d0ccc0" stop-opacity="0.8"/>
                </radialGradient>
                <radialGradient id="moonDark" cx="50%" cy="50%" r="50%">
                    <stop offset="0%" stop-color="%231a1a1a"/>
                    <stop offset="100%" stop-color="%23111"/>
                </radialGradient>
                <filter id="blur" x="-20%" y="-20%" width="140%" height="140%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0.5"/>
                </filter>
            </defs>`;
            
            // Outer glow ring
            svg += `<circle cx="${cx}" cy="${cy}" r="${r+4}" fill="none" stroke="%23fff" stroke-width="1" opacity="0.15"/>`;
            
            if (phase < 0.02 || phase > 0.98) {
                // New Moon - dark with subtle outline
                svg += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="url(%23moonDark)" stroke="%23444" stroke-width="1.5"/>`;
                svg += `<circle cx="${cx}" cy="${cy}" r="${r-1}" fill="none" stroke="%23222" stroke-width="0.5" opacity="0.5"/>`;
            } else if (phase > 0.48 && phase < 0.52) {
                // Full Moon - fully lit with craters
                svg += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="url(%23moonGlow)" stroke="%23ccc" stroke-width="1"/>`;
                // Add crater details
                svg += `<circle cx="${cx-12}" cy="${cy-8}" r="8" fill="%23d5d0c5" opacity="0.4"/>`;
                svg += `<circle cx="${cx+15}" cy="${cy+12}" r="6" fill="%23d5d0c5" opacity="0.3"/>`;
                svg += `<circle cx="${cx-5}" cy="${cy+18}" r="10" fill="%23d5d0c5" opacity="0.35"/>`;
                svg += `<circle cx="${cx+8}" cy="${cy-15}" r="4" fill="%23d5d0c5" opacity="0.25"/>`;
            } else {
                // Partial phases - use clipping path for smooth terminator
                const litSide = isWaxing ? 'right' : 'left';
                
                // Draw dark background
                svg += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="url(%23moonDark)" stroke="%23444" stroke-width="1"/>`;
                
                // Calculate the illuminated portion using ellipse
                const illuminatedWidth = Math.abs(terminatorX);
                
                if (isWaxing) {
                    // Right side illuminated, growing
                    if (adjustedPhase < 0.25) {
                        // Crescent - small illuminated arc on right
                        svg += `<path d="M ${cx} ${cy-r} A ${r} ${r} 0 0 1 ${cx} ${cy+r} A ${illuminatedWidth} ${r} 0 0 0 ${cx} ${cy-r}" fill="url(%23moonGlow)" filter="url(%23blur)"/>`;
                    } else {
                        // Gibbous - large illuminated area, small shadow on left
                        svg += `<path d="M ${cx} ${cy-r} A ${r} ${r} 0 0 1 ${cx} ${cy+r} A ${illuminatedWidth} ${r} 0 0 1 ${cx} ${cy-r}" fill="url(%23moonGlow)" filter="url(%23blur)"/>`;
                    }
                } else {
                    // Left side illuminated, shrinking (waning)
                    if (adjustedPhase < 0.25) {
                        // Gibbous waning - large lit area, shadow growing on right
                        svg += `<path d="M ${cx} ${cy-r} A ${r} ${r} 0 0 0 ${cx} ${cy+r} A ${illuminatedWidth} ${r} 0 0 0 ${cx} ${cy-r}" fill="url(%23moonGlow)" filter="url(%23blur)"/>`;
                    } else {
                        // Crescent waning - small lit arc on left
                        svg += `<path d="M ${cx} ${cy-r} A ${r} ${r} 0 0 0 ${cx} ${cy+r} A ${illuminatedWidth} ${r} 0 0 1 ${cx} ${cy-r}" fill="url(%23moonGlow)" filter="url(%23blur)"/>`;
                    }
                }
                
                // Add subtle crater details on lit portion
                if (illuminationPercent > 30) {
                    const craterOpacity = Math.min(0.3, illuminationPercent / 100 * 0.4);
                    if (isWaxing || phase > 0.75) {
                        svg += `<circle cx="${cx+10}" cy="${cy-5}" r="5" fill="%23c5c0b5" opacity="${craterOpacity}"/>`;
                        svg += `<circle cx="${cx+5}" cy="${cy+15}" r="7" fill="%23c5c0b5" opacity="${craterOpacity * 0.8}"/>`;
                    }
                    if (!isWaxing || phase < 0.25) {
                        svg += `<circle cx="${cx-12}" cy="${cy}" r="6" fill="%23c5c0b5" opacity="${craterOpacity}"/>`;
                        svg += `<circle cx="${cx-5}" cy="${cy-12}" r="4" fill="%23c5c0b5" opacity="${craterOpacity * 0.7}"/>`;
                    }
                }
            }
            
            svg += '</svg>';
            
            return 'data:image/svg+xml,' + encodeURIComponent(svg).replace(/'/g, "%27");
        }

        // Alert system
        function checkForAlerts(data) {
            const kp = data.kp_index || 0;
            const alertBanner = document.getElementById('alert-banner');
            const alertMessage = document.getElementById('alert-message');
            
            if (kp >= 5) {
                let level = 'G1 (Minor)';
                let color = '#f59e0b';
                
                if (kp >= 9) {
                    level = 'G5 (Extreme)';
                    color = '#dc2626';
                } else if (kp >= 8) {
                    level = 'G4 (Severe)';
                    color = '#ef4444';
                } else if (kp >= 7) {
                    level = 'G3 (Strong)';
                    color = '#f97316';
                } else if (kp >= 6) {
                    level = 'G2 (Moderate)';
                    color = '#fb923c';
                }
                
                alertMessage.textContent = `${level} geomagnetic storm in progress (Kp ${formatKp(kp)}). Aurora may be visible at lower latitudes.`;
                alertBanner.style.borderColor = color;
                alertBanner.style.display = 'block';
            } else {
                alertBanner.style.display = 'none';
            }
        }

        // System Alert functions
        async function checkSystemAlert() {
            try {
                const response = await fetch('/api/system-alert');
                const payload = await response.json();

                // Support both shapes: {alerts: [...]} or an array, or single object
                let alerts = [];
                if (Array.isArray(payload)) alerts = payload;
                else if (payload && Array.isArray(payload.alerts)) alerts = payload.alerts;
                else if (payload && typeof payload === 'object') alerts = [payload];

                renderSystemAlerts(alerts);
            } catch (error) {
                console.warn('Unable to fetch system alert configuration. Alerts will not be displayed.', error);
                // Clear any existing alerts on error
                clearSystemAlerts();
            }
        }

        function renderSystemAlerts(alerts) {
            const container = document.getElementById('system-alerts-container');
            container.innerHTML = '';

            if (!alerts || alerts.length === 0) return;

            alerts.forEach((config, idx) => {
                // Skip disabled alerts
                if (!config.enabled) return;

                const messageText = config.message || '';
                const dismissedKey = `dismissed_alert_${hashString(messageText)}`;
                if (config.dismissible && localStorage.getItem(dismissedKey) === 'true') return;

                // Build banner element
                const banner = document.createElement('div');
                banner.className = 'system-alert-banner';
                banner.style.borderRadius = '3px';
                banner.style.padding = '0.75rem 1rem';
                banner.style.marginBottom = '0.5rem';

                const inner = document.createElement('div');
                inner.style.display = 'flex';
                inner.style.alignItems = 'center';
                inner.style.gap = '0.75rem';

                const icon = document.createElement('span');
                icon.style.fontSize = '1.5rem';

                const body = document.createElement('div');
                body.style.flex = '1';

                const titleEl = document.createElement('div');
                titleEl.style.fontWeight = '600';
                titleEl.style.marginBottom = '0.25rem';

                const messageEl = document.createElement('div');
                messageEl.style.color = '#e5e5e5';
                messageEl.style.fontSize = '0.9rem';

                const closeBtn = document.createElement('button');
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#8b8b8b';
                closeBtn.style.fontSize = '1.2rem';
                closeBtn.style.cursor = 'pointer';
                closeBtn.style.padding = '0.25rem 0.5rem';
                closeBtn.textContent = 'Ã—';

                // Set textual content and styles based on type
                function escapeHtml(str) {
                    return String(str || '').replace(/[&<>"']/g, function (s) {
                        return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[s];
                    });
                }

                let processed = escapeHtml(messageText);
                if (config.issue_repo) {
                    processed = processed.replace(/(^|\s)#(\d+)\b/g, function (_, pre, id) {
                        return pre + `<a href="https://github.com/${config.issue_repo}/issues/${id}" target="_blank" rel="noopener noreferrer">#${id}</a>`;
                    });
                }

                // Type styling
                let bgColor = 'rgba(59, 130, 246, 0.12)', borderColor = '#3b82f6', iconText = '', titleText = 'System Notice';
                switch (config.type) {
                    case 'warning':
                        bgColor = 'rgba(251, 146, 60, 0.12)'; borderColor = '#fb923c'; iconText = ''; titleText = 'Warning'; break;
                    case 'error':
                        bgColor = 'rgba(239, 68, 68, 0.12)'; borderColor = '#ef4444'; iconText = ''; titleText = 'Important Notice'; break;
                    case 'success':
                        bgColor = 'rgba(34, 197, 94, 0.12)'; borderColor = '#22c55e'; iconText = ''; titleText = 'System Update'; break;
                    case 'info':
                    default:
                        break;
                }

                banner.style.background = bgColor;
                banner.style.border = `1px solid ${borderColor}`;
                icon.textContent = iconText;
                titleEl.textContent = titleText;
                titleEl.style.color = borderColor;
                messageEl.innerHTML = processed;

                // Wire close behavior
                if (config.dismissible) {
                    closeBtn.addEventListener('click', () => {
                        localStorage.setItem(dismissedKey, 'true');
                        banner.remove();
                    });
                } else {
                    closeBtn.style.display = 'none';
                }

                body.appendChild(titleEl);
                body.appendChild(messageEl);
                inner.appendChild(icon);
                inner.appendChild(body);
                inner.appendChild(closeBtn);
                banner.appendChild(inner);

                container.appendChild(banner);
            });
        }

        function clearSystemAlerts() {
            const container = document.getElementById('system-alerts-container');
            container.innerHTML = '';
        }

        // Simple string hash function for generating consistent keys
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash | 0; // Convert to 32bit integer
            }
            return Math.abs(hash).toString(36);
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const icon = document.getElementById('toast-icon');
            const msg = document.getElementById('toast-message');

            msg.textContent = message;
            // No emoji icons: leave icon text empty
            icon.textContent = '';
            toast.className = `toast toast-${type} show`;

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        function toggleMobileMenu() {
            const navLinks = document.getElementById('nav-links');
            navLinks.classList.toggle('active');
        }
    </script>
</body>
</html>
